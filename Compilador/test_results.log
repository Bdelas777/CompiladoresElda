
================================================================================
SESIÓN DE PRUEBAS - 2025-05-31 17:49:18
================================================================================


[TEST 1] Operaciones Básicas
------------------------------------------------------------
CÓDIGO:
 1: program operaciones_basicas;
 2: var
 3:     a, b, c, resultado, resultado2 : int;
 4:     resultado3 : float;
 5: 
 6: main {
 7:     a = 5;
 8:     b = 3;
 9:     c = 2;
10:     
11:     resultado = a + b * c;
12:     print("Resultado 1: ", resultado);
13:     
14:     resultado2 = (a + b) * c;
15:     print("Resultado 2: ", resultado2);
16:     
17:     resultado3 = a - b / c;
18:     print("Resultado 3: ", resultado3);
19:     
20:     resultado = a + b + c;
21:     print("Resultado 4: ", resultado);
22:     
23:     resultado2 = a + b * c * 2;
24:     print("Resultado 5: ", resultado2);
25:     
26:     resultado3 = a + b + c * 2;
27:     print("Resultado 6: ", resultado3);
28:     
29:     resultado3 = a  - b * c *2 + 1 ;
30:     print("Resultado 7: ", resultado3);
31: }
32: end

SALIDA OBTENIDA:
Agregando ID 'a' a lista temporal en ámbito: global
'a' agregado a lista temporal de variables en ámbito: global
Agregando ID 'b' a lista temporal en ámbito: global
'b' agregado a lista temporal de variables en ámbito: global
Agregando ID 'c' a lista temporal en ámbito: global
'c' agregado a lista temporal de variables en ámbito: global
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Agregando ID 'resultado2' a lista temporal en ámbito: global
'resultado2' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'a' agregada de tipo Type.INT en dirección 5000
Variable global 'b' agregada de tipo Type.INT en dirección 5001
Variable global 'c' agregada de tipo Type.INT en dirección 5002
Variable global 'resultado' agregada de tipo Type.INT en dirección 5003
Variable global 'resultado2' agregada de tipo Type.INT en dirección 5004
Agregando ID 'resultado3' a lista temporal en ámbito: global
'resultado3' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.FLOAT
Agregando variables a tabla en ámbito: global
Variable global 'resultado3' agregada de tipo Type.FLOAT en dirección 8000
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa operaciones_basicas iniciado, ámbito reiniciado a global
Programa operaciones_basicas completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: main - Dirección de Inicio: 1
----------------------------------------------------------------------
0: (goto, None, None, 1)
        saltar al cuádruplo 1
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 5000)
        asignar valor de constante(5) a a (global)
----------------------------------------------------------------------
2: (=, 20001, None, 5001)
        asignar valor de constante(3) a b (global)
----------------------------------------------------------------------
3: (=, 20002, None, 5002)
        asignar valor de constante(2) a c (global)
----------------------------------------------------------------------
4: (*, 5001, 5002, 15000)
        multiplicar b (global) y c (global), guardar resultado en dir:15000
----------------------------------------------------------------------
5: (+, 5000, 15000, 15001)
        sumar a (global) y dir:15000, guardar resultado en dir:15001
----------------------------------------------------------------------
6: (=, 15001, None, 5003)
        asignar valor de dir:15001 a resultado (global)
----------------------------------------------------------------------
7: (print, Resultado 1: , None, None)
        imprimir valor dir:Resultado 1: 
----------------------------------------------------------------------
8: (print, 5003, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
9: (+, 5000, 5001, 15002)
        sumar a (global) y b (global), guardar resultado en dir:15002
----------------------------------------------------------------------
10: (*, 15002, 5002, 15003)
        multiplicar dir:15002 y c (global), guardar resultado en dir:15003
----------------------------------------------------------------------
11: (=, 15003, None, 5004)
        asignar valor de dir:15003 a resultado2 (global)
----------------------------------------------------------------------
12: (print, Resultado 2: , None, None)
        imprimir valor dir:Resultado 2: 
----------------------------------------------------------------------
13: (print, 5004, None, None)
        imprimir valor resultado2 (global)
----------------------------------------------------------------------
14: (/, 5001, 5002, 17000)
        dividir b (global) y c (global), guardar resultado en dir:17000
----------------------------------------------------------------------
15: (-, 5000, 17000, 17001)
        restar a (global) y dir:17000, guardar resultado en dir:17001
----------------------------------------------------------------------
16: (=, 17001, None, 8000)
        asignar valor de dir:17001 a resultado3 (global)
----------------------------------------------------------------------
17: (print, Resultado 3: , None, None)
        imprimir valor dir:Resultado 3: 
----------------------------------------------------------------------
18: (print, 8000, None, None)
        imprimir valor resultado3 (global)
----------------------------------------------------------------------
19: (+, 5000, 5001, 15004)
        sumar a (global) y b (global), guardar resultado en dir:15004
----------------------------------------------------------------------
20: (+, 15004, 5002, 15005)
        sumar dir:15004 y c (global), guardar resultado en dir:15005
----------------------------------------------------------------------
21: (=, 15005, None, 5003)
        asignar valor de dir:15005 a resultado (global)
----------------------------------------------------------------------
22: (print, Resultado 4: , None, None)
        imprimir valor dir:Resultado 4: 
----------------------------------------------------------------------
23: (print, 5003, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
24: (*, 5001, 5002, 15006)
        multiplicar b (global) y c (global), guardar resultado en dir:15006
----------------------------------------------------------------------
25: (*, 15006, 20002, 15007)
        multiplicar dir:15006 y constante(2), guardar resultado en dir:15007
----------------------------------------------------------------------
26: (+, 5000, 15007, 15008)
        sumar a (global) y dir:15007, guardar resultado en dir:15008
----------------------------------------------------------------------
27: (=, 15008, None, 5004)
        asignar valor de dir:15008 a resultado2 (global)
----------------------------------------------------------------------
28: (print, Resultado 5: , None, None)
        imprimir valor dir:Resultado 5: 
----------------------------------------------------------------------
29: (print, 5004, None, None)
        imprimir valor resultado2 (global)
----------------------------------------------------------------------
30: (*, 5002, 20002, 15009)
        multiplicar c (global) y constante(2), guardar resultado en dir:15009
----------------------------------------------------------------------
31: (+, 5000, 5001, 15010)
        sumar a (global) y b (global), guardar resultado en dir:15010
----------------------------------------------------------------------
32: (+, 15010, 15009, 15011)
        sumar dir:15010 y dir:15009, guardar resultado en dir:15011
----------------------------------------------------------------------
33: (=, 15011, None, 8000)
        asignar valor de dir:15011 a resultado3 (global)
----------------------------------------------------------------------
34: (print, Resultado 6: , None, None)
        imprimir valor dir:Resultado 6: 
----------------------------------------------------------------------
35: (print, 8000, None, None)
        imprimir valor resultado3 (global)
----------------------------------------------------------------------
36: (*, 5001, 5002, 15012)
        multiplicar b (global) y c (global), guardar resultado en dir:15012
----------------------------------------------------------------------
37: (*, 15012, 20002, 15013)
        multiplicar dir:15012 y constante(2), guardar resultado en dir:15013
----------------------------------------------------------------------
38: (-, 5000, 15013, 15014)
        restar a (global) y dir:15013, guardar resultado en dir:15014
----------------------------------------------------------------------
39: (+, 15014, 20003, 15015)
        sumar dir:15014 y constante(1), guardar resultado en dir:15015
----------------------------------------------------------------------
40: (=, 15015, None, 8000)
        asignar valor de dir:15015 a resultado3 (global)
----------------------------------------------------------------------
41: (print, Resultado 7: , None, None)
        imprimir valor dir:Resultado 7: 
----------------------------------------------------------------------
42: (print, 8000, None, None)
        imprimir valor resultado3 (global)
----------------------------------------------------------------------
43: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 1)
  Salto a: 1
IP: 1 -> Ejecutando: (=, 20000, None, 5000)
  Asignación: direccion[5000] = 5
IP: 2 -> Ejecutando: (=, 20001, None, 5001)
  Asignación: direccion[5001] = 3
IP: 3 -> Ejecutando: (=, 20002, None, 5002)
  Asignación: direccion[5002] = 2
IP: 4 -> Ejecutando: (*, 5001, 5002, 15000)
  Aritmética: 3 * 2 = 6
IP: 5 -> Ejecutando: (+, 5000, 15000, 15001)
  Aritmética: 5 + 6 = 11
IP: 6 -> Ejecutando: (=, 15001, None, 5003)
  Asignación: direccion[5003] = 11
IP: 7 -> Ejecutando: (print, Resultado 1: , None, None)
OUTPUT: Resultado 1: 
IP: 8 -> Ejecutando: (print, 5003, None, None)
OUTPUT: 11
IP: 9 -> Ejecutando: (+, 5000, 5001, 15002)
  Aritmética: 5 + 3 = 8
IP: 10 -> Ejecutando: (*, 15002, 5002, 15003)
  Aritmética: 8 * 2 = 16
IP: 11 -> Ejecutando: (=, 15003, None, 5004)
  Asignación: direccion[5004] = 16
IP: 12 -> Ejecutando: (print, Resultado 2: , None, None)
OUTPUT: Resultado 2: 
IP: 13 -> Ejecutando: (print, 5004, None, None)
OUTPUT: 16
IP: 14 -> Ejecutando: (/, 5001, 5002, 17000)
  Aritmética: 3 / 2 = 1.5
IP: 15 -> Ejecutando: (-, 5000, 17000, 17001)
  Aritmética: 5 - 1.5 = 3.5
IP: 16 -> Ejecutando: (=, 17001, None, 8000)
  Asignación: direccion[8000] = 3.5
IP: 17 -> Ejecutando: (print, Resultado 3: , None, None)
OUTPUT: Resultado 3: 
IP: 18 -> Ejecutando: (print, 8000, None, None)
OUTPUT: 3.5
IP: 19 -> Ejecutando: (+, 5000, 5001, 15004)
  Aritmética: 5 + 3 = 8
IP: 20 -> Ejecutando: (+, 15004, 5002, 15005)
  Aritmética: 8 + 2 = 10
IP: 21 -> Ejecutando: (=, 15005, None, 5003)
  Asignación: direccion[5003] = 10
IP: 22 -> Ejecutando: (print, Resultado 4: , None, None)
OUTPUT: Resultado 4: 
IP: 23 -> Ejecutando: (print, 5003, None, None)
OUTPUT: 10
IP: 24 -> Ejecutando: (*, 5001, 5002, 15006)
  Aritmética: 3 * 2 = 6
IP: 25 -> Ejecutando: (*, 15006, 20002, 15007)
  Aritmética: 6 * 2 = 12
IP: 26 -> Ejecutando: (+, 5000, 15007, 15008)
  Aritmética: 5 + 12 = 17
IP: 27 -> Ejecutando: (=, 15008, None, 5004)
  Asignación: direccion[5004] = 17
IP: 28 -> Ejecutando: (print, Resultado 5: , None, None)
OUTPUT: Resultado 5: 
IP: 29 -> Ejecutando: (print, 5004, None, None)
OUTPUT: 17
IP: 30 -> Ejecutando: (*, 5002, 20002, 15009)
  Aritmética: 2 * 2 = 4
IP: 31 -> Ejecutando: (+, 5000, 5001, 15010)
  Aritmética: 5 + 3 = 8
IP: 32 -> Ejecutando: (+, 15010, 15009, 15011)
  Aritmética: 8 + 4 = 12
IP: 33 -> Ejecutando: (=, 15011, None, 8000)
  Asignación: direccion[8000] = 12
IP: 34 -> Ejecutando: (print, Resultado 6: , None, None)
OUTPUT: Resultado 6: 
IP: 35 -> Ejecutando: (print, 8000, None, None)
OUTPUT: 12.0
IP: 36 -> Ejecutando: (*, 5001, 5002, 15012)
  Aritmética: 3 * 2 = 6
IP: 37 -> Ejecutando: (*, 15012, 20002, 15013)
  Aritmética: 6 * 2 = 12
IP: 38 -> Ejecutando: (-, 5000, 15013, 15014)
  Aritmética: 5 - 12 = -7
IP: 39 -> Ejecutando: (+, 15014, 20003, 15015)
  Aritmética: -7 + 1 = -6
IP: 40 -> Ejecutando: (=, 15015, None, 8000)
  Asignación: direccion[8000] = -6
IP: 41 -> Ejecutando: (print, Resultado 7: , None, None)
OUTPUT: Resultado 7: 
IP: 42 -> Ejecutando: (print, 8000, None, None)
OUTPUT: -6.0
IP: 43 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 5
  [5001]: 3
  [5002]: 2
  [5003]: 10
  [5004]: 17
Memoria Global Flotantes (8000-10999):
  [8000]: -6.0
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 6
  [15001]: 11
  [15002]: 8
  [15003]: 16
  [15004]: 8
  [15005]: 10
  [15006]: 6
  [15007]: 12
  [15008]: 17
  [15009]: 4
  [15010]: 8
  [15011]: 12
  [15012]: 6
  [15013]: 12
  [15014]: -7
  [15015]: -6
Memoria Temporal Flotantes (17000-18999):
  [17000]: 1.5
  [17001]: 3.5
Memoria Temporal Booleanos (19000-19999):
Constantes Enteras (20000-20499):
  [20000]: 5
  [20001]: 3
  [20002]: 2
  [20003]: 1
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - 11
  - 16
  - 3.5
  - 10
  - 17
  - 12
  - -6

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 2] Control IF
------------------------------------------------------------
CÓDIGO:
 1: program control_if;
 2: var
 3:     x, y, max : int;
 4: main {
 5:     x = 15;
 6:     y = 7;
 7:     
 8:     if (x > y) {
 9:         max = x;
10:         print("El mayor es x: ", max);
11:     } else {
12:         max = y;
13:         print("El mayor es y: ", max);
14:     };
15:     
16:     if (x < 10) {
17:         print("x es menor que 10");
18:     } else {
19:         print("x es mayor o igual que 10");
20:     };
21: }
22: end

SALIDA OBTENIDA:
Agregando ID 'x' a lista temporal en ámbito: global
'x' agregado a lista temporal de variables en ámbito: global
Agregando ID 'y' a lista temporal en ámbito: global
'y' agregado a lista temporal de variables en ámbito: global
Agregando ID 'max' a lista temporal en ámbito: global
'max' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'x' agregada de tipo Type.INT en dirección 5000
Variable global 'y' agregada de tipo Type.INT en dirección 5001
Variable global 'max' agregada de tipo Type.INT en dirección 5002
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa control_if iniciado, ámbito reiniciado a global
Programa control_if completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: main - Dirección de Inicio: 1
----------------------------------------------------------------------
0: (goto, None, None, 1)
        saltar al cuádruplo 1
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 5000)
        asignar valor de constante(15) a x (global)
----------------------------------------------------------------------
2: (=, 20001, None, 5001)
        asignar valor de constante(7) a y (global)
----------------------------------------------------------------------
3: (>, 5000, 5001, 19000)
        comparar si x (global) es mayor que y (global), guardar resultado booleano en dir:19000
----------------------------------------------------------------------
4: (gotof, 19000, None, 9)
        si dir:19000 es falso, saltar al cuádruplo 9
----------------------------------------------------------------------
5: (=, 5000, None, 5002)
        asignar valor de x (global) a max (global)
----------------------------------------------------------------------
6: (print, El mayor es x: , None, None)
        imprimir valor dir:El mayor es x: 
----------------------------------------------------------------------
7: (print, 5002, None, None)
        imprimir valor max (global)
----------------------------------------------------------------------
8: (goto, None, None, 12)
        saltar al cuádruplo 12
----------------------------------------------------------------------
9: (=, 5001, None, 5002)
        asignar valor de y (global) a max (global)
----------------------------------------------------------------------
10: (print, El mayor es y: , None, None)
        imprimir valor dir:El mayor es y: 
----------------------------------------------------------------------
11: (print, 5002, None, None)
        imprimir valor max (global)
----------------------------------------------------------------------
12: (<, 5000, 20002, 19001)
        comparar si x (global) es menor que constante(10), guardar resultado booleano en dir:19001
----------------------------------------------------------------------
13: (gotof, 19001, None, 16)
        si dir:19001 es falso, saltar al cuádruplo 16
----------------------------------------------------------------------
14: (print, x es menor que 10, None, None)
        imprimir valor dir:x es menor que 10
----------------------------------------------------------------------
15: (goto, None, None, 17)
        saltar al cuádruplo 17
----------------------------------------------------------------------
16: (print, x es mayor o igual que 10, None, None)
        imprimir valor dir:x es mayor o igual que 10
----------------------------------------------------------------------
17: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 1)
  Salto a: 1
IP: 1 -> Ejecutando: (=, 20000, None, 5000)
  Asignación: direccion[5000] = 15
IP: 2 -> Ejecutando: (=, 20001, None, 5001)
  Asignación: direccion[5001] = 7
IP: 3 -> Ejecutando: (>, 5000, 5001, 19000)
  Comparación: 15 > 7 = True
IP: 4 -> Ejecutando: (gotof, 19000, None, 9)
  No hay salto (condición verdadera)
IP: 5 -> Ejecutando: (=, 5000, None, 5002)
  Asignación: direccion[5002] = 15
IP: 6 -> Ejecutando: (print, El mayor es x: , None, None)
OUTPUT: El mayor es x: 
IP: 7 -> Ejecutando: (print, 5002, None, None)
OUTPUT: 15
IP: 8 -> Ejecutando: (goto, None, None, 12)
  Salto a: 12
IP: 12 -> Ejecutando: (<, 5000, 20002, 19001)
  Comparación: 15 < 10 = False
IP: 13 -> Ejecutando: (gotof, 19001, None, 16)
  Salto condicional a: 16 (condición falsa)
IP: 16 -> Ejecutando: (print, x es mayor o igual que 10, None, None)
OUTPUT: x es mayor o igual que 10
IP: 17 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 15
  [5001]: 7
  [5002]: 15
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: True
  [19001]: False
Constantes Enteras (20000-20499):
  [20000]: 15
  [20001]: 7
  [20002]: 10
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - El mayor es x:
  - 15
  - x es mayor o igual que 10

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 3] Ciclo WHILE
------------------------------------------------------------
CÓDIGO:
 1: program ciclo_while;
 2: var
 3:     contador, suma : int;
 4: main {
 5:     contador = 1;
 6:     suma = 0;
 7:     
 8:     while (contador < 5) do {
 9:         suma = suma + contador;
10:         print("Iteración: ", contador, " Suma actual: ", suma);
11:         contador = contador + 1;
12:     };
13:     
14:     print("Suma final: ", suma);
15: }
16: end

SALIDA OBTENIDA:
Agregando ID 'contador' a lista temporal en ámbito: global
'contador' agregado a lista temporal de variables en ámbito: global
Agregando ID 'suma' a lista temporal en ámbito: global
'suma' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'contador' agregada de tipo Type.INT en dirección 5000
Variable global 'suma' agregada de tipo Type.INT en dirección 5001
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa ciclo_while iniciado, ámbito reiniciado a global
Programa ciclo_while completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: main - Dirección de Inicio: 1
----------------------------------------------------------------------
0: (goto, None, None, 1)
        saltar al cuádruplo 1
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 5000)
        asignar valor de constante(1) a contador (global)
----------------------------------------------------------------------
2: (=, 20001, None, 5001)
        asignar valor de constante(0) a suma (global)
----------------------------------------------------------------------
3: (<, 5000, 20002, 19000)
        comparar si contador (global) es menor que constante(5), guardar resultado booleano en dir:19000
----------------------------------------------------------------------
4: (gotof, 19000, None, 14)
        si dir:19000 es falso, saltar al cuádruplo 14
----------------------------------------------------------------------
5: (+, 5001, 5000, 15000)
        sumar suma (global) y contador (global), guardar resultado en dir:15000
----------------------------------------------------------------------
6: (=, 15000, None, 5001)
        asignar valor de dir:15000 a suma (global)
----------------------------------------------------------------------
7: (print, Iteración: , None, None)
        imprimir valor dir:Iteración: 
----------------------------------------------------------------------
8: (print, 5000, None, None)
        imprimir valor contador (global)
----------------------------------------------------------------------
9: (print,  Suma actual: , None, None)
        imprimir valor dir: Suma actual: 
----------------------------------------------------------------------
10: (print, 5001, None, None)
        imprimir valor suma (global)
----------------------------------------------------------------------
11: (+, 5000, 20000, 15001)
        sumar contador (global) y constante(1), guardar resultado en dir:15001
----------------------------------------------------------------------
12: (=, 15001, None, 5000)
        asignar valor de dir:15001 a contador (global)
----------------------------------------------------------------------
13: (goto, None, None, 3)
        saltar al cuádruplo 3
----------------------------------------------------------------------
14: (print, Suma final: , None, None)
        imprimir valor dir:Suma final: 
----------------------------------------------------------------------
15: (print, 5001, None, None)
        imprimir valor suma (global)
----------------------------------------------------------------------
16: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 1)
  Salto a: 1
IP: 1 -> Ejecutando: (=, 20000, None, 5000)
  Asignación: direccion[5000] = 1
IP: 2 -> Ejecutando: (=, 20001, None, 5001)
  Asignación: direccion[5001] = 0
IP: 3 -> Ejecutando: (<, 5000, 20002, 19000)
  Comparación: 1 < 5 = True
IP: 4 -> Ejecutando: (gotof, 19000, None, 14)
  No hay salto (condición verdadera)
IP: 5 -> Ejecutando: (+, 5001, 5000, 15000)
  Aritmética: 0 + 1 = 1
IP: 6 -> Ejecutando: (=, 15000, None, 5001)
  Asignación: direccion[5001] = 1
IP: 7 -> Ejecutando: (print, Iteración: , None, None)
OUTPUT: Iteración: 
IP: 8 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 1
IP: 9 -> Ejecutando: (print,  Suma actual: , None, None)
OUTPUT:  Suma actual: 
IP: 10 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 1
IP: 11 -> Ejecutando: (+, 5000, 20000, 15001)
  Aritmética: 1 + 1 = 2
IP: 12 -> Ejecutando: (=, 15001, None, 5000)
  Asignación: direccion[5000] = 2
IP: 13 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (<, 5000, 20002, 19000)
  Comparación: 2 < 5 = True
IP: 4 -> Ejecutando: (gotof, 19000, None, 14)
  No hay salto (condición verdadera)
IP: 5 -> Ejecutando: (+, 5001, 5000, 15000)
  Aritmética: 1 + 2 = 3
IP: 6 -> Ejecutando: (=, 15000, None, 5001)
  Asignación: direccion[5001] = 3
IP: 7 -> Ejecutando: (print, Iteración: , None, None)
OUTPUT: Iteración: 
IP: 8 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 2
IP: 9 -> Ejecutando: (print,  Suma actual: , None, None)
OUTPUT:  Suma actual: 
IP: 10 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 3
IP: 11 -> Ejecutando: (+, 5000, 20000, 15001)
  Aritmética: 2 + 1 = 3
IP: 12 -> Ejecutando: (=, 15001, None, 5000)
  Asignación: direccion[5000] = 3
IP: 13 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (<, 5000, 20002, 19000)
  Comparación: 3 < 5 = True
IP: 4 -> Ejecutando: (gotof, 19000, None, 14)
  No hay salto (condición verdadera)
IP: 5 -> Ejecutando: (+, 5001, 5000, 15000)
  Aritmética: 3 + 3 = 6
IP: 6 -> Ejecutando: (=, 15000, None, 5001)
  Asignación: direccion[5001] = 6
IP: 7 -> Ejecutando: (print, Iteración: , None, None)
OUTPUT: Iteración: 
IP: 8 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 3
IP: 9 -> Ejecutando: (print,  Suma actual: , None, None)
OUTPUT:  Suma actual: 
IP: 10 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 6
IP: 11 -> Ejecutando: (+, 5000, 20000, 15001)
  Aritmética: 3 + 1 = 4
IP: 12 -> Ejecutando: (=, 15001, None, 5000)
  Asignación: direccion[5000] = 4
IP: 13 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (<, 5000, 20002, 19000)
  Comparación: 4 < 5 = True
IP: 4 -> Ejecutando: (gotof, 19000, None, 14)
  No hay salto (condición verdadera)
IP: 5 -> Ejecutando: (+, 5001, 5000, 15000)
  Aritmética: 6 + 4 = 10
IP: 6 -> Ejecutando: (=, 15000, None, 5001)
  Asignación: direccion[5001] = 10
IP: 7 -> Ejecutando: (print, Iteración: , None, None)
OUTPUT: Iteración: 
IP: 8 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 4
IP: 9 -> Ejecutando: (print,  Suma actual: , None, None)
OUTPUT:  Suma actual: 
IP: 10 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 10
IP: 11 -> Ejecutando: (+, 5000, 20000, 15001)
  Aritmética: 4 + 1 = 5
IP: 12 -> Ejecutando: (=, 15001, None, 5000)
  Asignación: direccion[5000] = 5
IP: 13 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (<, 5000, 20002, 19000)
  Comparación: 5 < 5 = False
IP: 4 -> Ejecutando: (gotof, 19000, None, 14)
  Salto condicional a: 14 (condición falsa)
IP: 14 -> Ejecutando: (print, Suma final: , None, None)
OUTPUT: Suma final: 
IP: 15 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 10
IP: 16 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 5
  [5001]: 10
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 10
  [15001]: 5
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
Constantes Enteras (20000-20499):
  [20000]: 1
  [20001]: 0
  [20002]: 5
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - Iteración:
  - 1
  - Suma actual:
  - 1
  - Iteración:
  - 2
  - Suma actual:
  - 3
  - Iteración:
  - 3
  - Suma actual:
  - 6
  - Iteración:
  - 4
  - Suma actual:
  - 10
  - Suma final:
  - 10

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 4] Funciones
------------------------------------------------------------
CÓDIGO:
 1: program funciones;
 2: var
 3:     resultado, num1, num2 : int;
 4: 
 5: void sumar(a : int, b : int)
 6: [
 7:     var res : int;
 8:     {
 9:         res = a + b;
10:         print("La suma es: ", res);
11:     }
12: ];
13: 
14: void multiplicar(c : int, d : int)
15: [
16:     var res : int;
17:     {
18:         res = c * d;
19:         print("El producto es: ", res);
20:     }
21: ];
22: 
23: main {
24:     num1 = 8;
25:     num2 = 3;
26:     
27:     sumar(num1, num2);
28:     multiplicar(num1, num2);
29:     
30:     sumar(5, 7);
31:     multiplicar(num1 + 2, num2 * 2);
32: }
33: end

SALIDA OBTENIDA:
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Agregando ID 'num1' a lista temporal en ámbito: global
'num1' agregado a lista temporal de variables en ámbito: global
Agregando ID 'num2' a lista temporal en ámbito: global
'num2' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'resultado' agregada de tipo Type.INT en dirección 5000
Variable global 'num1' agregada de tipo Type.INT en dirección 5001
Variable global 'num2' agregada de tipo Type.INT en dirección 5002
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: sumar, pila de ámbitos actual: ['global', 'sumar']
Función 'sumar' declarada con tipo de retorno Type.VOID, ámbito cambiado a: sumar
Parámetro 'a' agregado de tipo Type.INT en dirección 11000 a función 'sumar'
Parámetro 'b' agregado de tipo Type.INT en dirección 11001 a función 'sumar'
Agregando ID 'res' a lista temporal en ámbito: sumar
'res' agregado a lista temporal de variables en ámbito: sumar
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: sumar
Variable local 'res' agregada de tipo Type.INT en dirección 11002 a función 'sumar'
Iniciando declaración de variables en ámbito 'sumar'
Ámbito removido: sumar, ámbito actual es ahora: global
Declaración de función 'sumar' terminada, regresado al ámbito: global
Ámbito agregado: multiplicar, pila de ámbitos actual: ['global', 'multiplicar']
Función 'multiplicar' declarada con tipo de retorno Type.VOID, ámbito cambiado a: multiplicar
Parámetro 'c' agregado de tipo Type.INT en dirección 11003 a función 'multiplicar'
Parámetro 'd' agregado de tipo Type.INT en dirección 11004 a función 'multiplicar'
Agregando ID 'res' a lista temporal en ámbito: multiplicar
'res' agregado a lista temporal de variables en ámbito: multiplicar
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: multiplicar
Variable local 'res' agregada de tipo Type.INT en dirección 11005 a función 'multiplicar'
Iniciando declaración de variables en ámbito 'multiplicar'
Ámbito removido: multiplicar, ámbito actual es ahora: global
Declaración de función 'multiplicar' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa funciones iniciado, ámbito reiniciado a global
Programa funciones completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: sumar - Dirección de Inicio: 1
Función: multiplicar - Dirección de Inicio: 6
Función: main - Dirección de Inicio: 11
----------------------------------------------------------------------
0: (goto, None, None, 11)
        saltar al cuádruplo 11
----------------------------------------------------------------------

==================== FUNCIÓN: sumar ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (+, 11000, 11001, 15000)
        sumar dir:11000 y dir:11001, guardar resultado en dir:15000
----------------------------------------------------------------------
2: (=, 15000, None, 11002)
        asignar valor de dir:15000 a dir:11002
----------------------------------------------------------------------
3: (print, La suma es: , None, None)
        imprimir valor dir:La suma es: 
----------------------------------------------------------------------
4: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
5: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE sumar ====================
----------------------------------------------------------------------

==================== FUNCIÓN: multiplicar ====================
Inicia en el cuádruplo 6
----------------------------------------------------------------------
6: (*, 11003, 11004, 15001)
        multiplicar dir:11003 y dir:11004, guardar resultado en dir:15001
----------------------------------------------------------------------
7: (=, 15001, None, 11005)
        asignar valor de dir:15001 a dir:11005
----------------------------------------------------------------------
8: (print, El producto es: , None, None)
        imprimir valor dir:El producto es: 
----------------------------------------------------------------------
9: (print, 11005, None, None)
        imprimir valor dir:11005
----------------------------------------------------------------------
10: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE multiplicar ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 11
----------------------------------------------------------------------
11: (=, 20000, None, 5001)
        asignar valor de constante(8) a num1 (global)
----------------------------------------------------------------------
12: (=, 20001, None, 5002)
        asignar valor de constante(3) a num2 (global)
----------------------------------------------------------------------
13: (ERA, sumar, None, None)
        realizar operación ERA con operando dir:sumar
----------------------------------------------------------------------
14: (parámetro, 5001, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
15: (parámetro, 5002, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
16: (GOSUB, sumar, None, None)
        realizar operación GOSUB con operando dir:sumar
----------------------------------------------------------------------
17: (ERA, multiplicar, None, None)
        realizar operación ERA con operando dir:multiplicar
----------------------------------------------------------------------
18: (parámetro, 5001, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
19: (parámetro, 5002, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
20: (GOSUB, multiplicar, None, None)
        realizar operación GOSUB con operando dir:multiplicar
----------------------------------------------------------------------
21: (ERA, sumar, None, None)
        realizar operación ERA con operando dir:sumar
----------------------------------------------------------------------
22: (parámetro, 20002, par1, None)
        realizar operación parámetro con operandos constante(5), dir:par1, resultado en None
----------------------------------------------------------------------
23: (parámetro, 20003, par2, None)
        realizar operación parámetro con operandos constante(7), dir:par2, resultado en None
----------------------------------------------------------------------
24: (GOSUB, sumar, None, None)
        realizar operación GOSUB con operando dir:sumar
----------------------------------------------------------------------
25: (ERA, multiplicar, None, None)
        realizar operación ERA con operando dir:multiplicar
----------------------------------------------------------------------
26: (+, 5001, 20004, 15002)
        sumar num1 (global) y constante(2), guardar resultado en dir:15002
----------------------------------------------------------------------
27: (parámetro, 15002, par1, None)
        realizar operación parámetro con operandos dir:15002, dir:par1, resultado en None
----------------------------------------------------------------------
28: (*, 5002, 20004, 15003)
        multiplicar num2 (global) y constante(2), guardar resultado en dir:15003
----------------------------------------------------------------------
29: (parámetro, 15003, par2, None)
        realizar operación parámetro con operandos dir:15003, dir:par2, resultado en None
----------------------------------------------------------------------
30: (GOSUB, multiplicar, None, None)
        realizar operación GOSUB con operando dir:multiplicar
----------------------------------------------------------------------
31: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 11)
  Salto a: 11
IP: 11 -> Ejecutando: (=, 20000, None, 5001)
  Asignación: direccion[5001] = 8
IP: 12 -> Ejecutando: (=, 20001, None, 5002)
  Asignación: direccion[5002] = 3
IP: 13 -> Ejecutando: (ERA, sumar, None, None)
  ERA: Reservando espacio para función 'sumar'
IP: 14 -> Ejecutando: (parámetro, 5001, par1, None)
  Parámetro: 8 -> posición 1
IP: 15 -> Ejecutando: (parámetro, 5002, par2, None)
  Parámetro: 3 -> posición 2
IP: 16 -> Ejecutando: (GOSUB, sumar, None, None)
    Asignando parámetro a (addr: 11000) = 8
    Asignando parámetro b (addr: 11001) = 3
  GOSUB: Llamando función 'sumar' en dirección 1
IP: 1 -> Ejecutando: (+, 11000, 11001, 15000)
  Aritmética: 8 + 3 = 11
IP: 2 -> Ejecutando: (=, 15000, None, 11002)
  Asignación: direccion[11002] = 11
IP: 3 -> Ejecutando: (print, La suma es: , None, None)
OUTPUT: La suma es: 
IP: 4 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 11
IP: 5 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 17
IP: 17 -> Ejecutando: (ERA, multiplicar, None, None)
  ERA: Reservando espacio para función 'multiplicar'
IP: 18 -> Ejecutando: (parámetro, 5001, par1, None)
  Parámetro: 8 -> posición 1
IP: 19 -> Ejecutando: (parámetro, 5002, par2, None)
  Parámetro: 3 -> posición 2
IP: 20 -> Ejecutando: (GOSUB, multiplicar, None, None)
    Asignando parámetro c (addr: 11003) = 8
    Asignando parámetro d (addr: 11004) = 3
  GOSUB: Llamando función 'multiplicar' en dirección 6
IP: 6 -> Ejecutando: (*, 11003, 11004, 15001)
  Aritmética: 8 * 3 = 24
IP: 7 -> Ejecutando: (=, 15001, None, 11005)
  Asignación: direccion[11005] = 24
IP: 8 -> Ejecutando: (print, El producto es: , None, None)
OUTPUT: El producto es: 
IP: 9 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 24
IP: 10 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 21
IP: 21 -> Ejecutando: (ERA, sumar, None, None)
  ERA: Reservando espacio para función 'sumar'
IP: 22 -> Ejecutando: (parámetro, 20002, par1, None)
  Parámetro: 5 -> posición 1
IP: 23 -> Ejecutando: (parámetro, 20003, par2, None)
  Parámetro: 7 -> posición 2
IP: 24 -> Ejecutando: (GOSUB, sumar, None, None)
    Asignando parámetro a (addr: 11000) = 5
    Asignando parámetro b (addr: 11001) = 7
  GOSUB: Llamando función 'sumar' en dirección 1
IP: 1 -> Ejecutando: (+, 11000, 11001, 15000)
  Aritmética: 5 + 7 = 12
IP: 2 -> Ejecutando: (=, 15000, None, 11002)
  Asignación: direccion[11002] = 12
IP: 3 -> Ejecutando: (print, La suma es: , None, None)
OUTPUT: La suma es: 
IP: 4 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 12
IP: 5 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 25
IP: 25 -> Ejecutando: (ERA, multiplicar, None, None)
  ERA: Reservando espacio para función 'multiplicar'
IP: 26 -> Ejecutando: (+, 5001, 20004, 15002)
  Aritmética: 8 + 2 = 10
IP: 27 -> Ejecutando: (parámetro, 15002, par1, None)
  Parámetro: 10 -> posición 1
IP: 28 -> Ejecutando: (*, 5002, 20004, 15003)
  Aritmética: 3 * 2 = 6
IP: 29 -> Ejecutando: (parámetro, 15003, par2, None)
  Parámetro: 6 -> posición 2
IP: 30 -> Ejecutando: (GOSUB, multiplicar, None, None)
    Asignando parámetro c (addr: 11003) = 10
    Asignando parámetro d (addr: 11004) = 6
  GOSUB: Llamando función 'multiplicar' en dirección 6
IP: 6 -> Ejecutando: (*, 11003, 11004, 15001)
  Aritmética: 10 * 6 = 60
IP: 7 -> Ejecutando: (=, 15001, None, 11005)
  Asignación: direccion[11005] = 60
IP: 8 -> Ejecutando: (print, El producto es: , None, None)
OUTPUT: El producto es: 
IP: 9 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 60
IP: 10 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 31
IP: 31 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5001]: 8
  [5002]: 3
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 12
  [15001]: 60
  [15002]: 10
  [15003]: 6
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
Constantes Enteras (20000-20499):
  [20000]: 8
  [20001]: 3
  [20002]: 5
  [20003]: 7
  [20004]: 2
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - La suma es:
  - 11
  - El producto es:
  - 24
  - La suma es:
  - 12
  - El producto es:
  - 60

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 5] Operaciones Flotantes
------------------------------------------------------------
CÓDIGO:
 1: program operaciones_flotantes;
 2: var
 3:     x : float;
 4:     y : int;
 5:     z : float;
 6: 
 7: main {
 8:     x = 3.5;
 9:     y = 2;
10:     
11:     z = x * y + 1.5;
12:     print("Resultado flotante: ", z);
13: }
14: end

SALIDA OBTENIDA:
Agregando ID 'x' a lista temporal en ámbito: global
'x' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.FLOAT
Agregando variables a tabla en ámbito: global
Variable global 'x' agregada de tipo Type.FLOAT en dirección 8000
Agregando ID 'y' a lista temporal en ámbito: global
'y' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'y' agregada de tipo Type.INT en dirección 5000
Agregando ID 'z' a lista temporal en ámbito: global
'z' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.FLOAT
Agregando variables a tabla en ámbito: global
Variable global 'z' agregada de tipo Type.FLOAT en dirección 8001
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa operaciones_flotantes iniciado, ámbito reiniciado a global
Programa operaciones_flotantes completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: main - Dirección de Inicio: 1
----------------------------------------------------------------------
0: (goto, None, None, 1)
        saltar al cuádruplo 1
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20500, None, 8000)
        asignar valor de constante(3.5) a x (global)
----------------------------------------------------------------------
2: (=, 20000, None, 5000)
        asignar valor de constante(2) a y (global)
----------------------------------------------------------------------
3: (*, 8000, 5000, 17000)
        multiplicar x (global) y y (global), guardar resultado en dir:17000
----------------------------------------------------------------------
4: (+, 17000, 20501, 17001)
        sumar dir:17000 y constante(1.5), guardar resultado en dir:17001
----------------------------------------------------------------------
5: (=, 17001, None, 8001)
        asignar valor de dir:17001 a z (global)
----------------------------------------------------------------------
6: (print, Resultado flotante: , None, None)
        imprimir valor dir:Resultado flotante: 
----------------------------------------------------------------------
7: (print, 8001, None, None)
        imprimir valor z (global)
----------------------------------------------------------------------
8: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 1)
  Salto a: 1
IP: 1 -> Ejecutando: (=, 20500, None, 8000)
  Asignación: direccion[8000] = 3.5
IP: 2 -> Ejecutando: (=, 20000, None, 5000)
  Asignación: direccion[5000] = 2
IP: 3 -> Ejecutando: (*, 8000, 5000, 17000)
  Aritmética: 3.5 * 2 = 7.0
IP: 4 -> Ejecutando: (+, 17000, 20501, 17001)
  Aritmética: 7.0 + 1.5 = 8.5
IP: 5 -> Ejecutando: (=, 17001, None, 8001)
  Asignación: direccion[8001] = 8.5
IP: 6 -> Ejecutando: (print, Resultado flotante: , None, None)
OUTPUT: Resultado flotante: 
IP: 7 -> Ejecutando: (print, 8001, None, None)
OUTPUT: 8.5
IP: 8 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 2
Memoria Global Flotantes (8000-10999):
  [8000]: 3.5
  [8001]: 8.5
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
Memoria Temporal Flotantes (17000-18999):
  [17000]: 7.0
  [17001]: 8.5
Memoria Temporal Booleanos (19000-19999):
Constantes Enteras (20000-20499):
  [20000]: 2
Constantes Flotantes (20500+):
  [20500]: 3.5
  [20501]: 1.5
========================================

RESULTADOS ESPERADOS:
  - 8.5

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 6] Números Negativos
------------------------------------------------------------
CÓDIGO:
 1: program negativos;
 2: var
 3:     a, b : int;
 4:     resultado : int;
 5: 
 6: main {
 7:     a = -5;
 8:     b = 3;
 9:     resultado = a + b;
10:     print("Resultado con negativos: ", resultado);
11: }
12: end

SALIDA OBTENIDA:
Agregando ID 'a' a lista temporal en ámbito: global
'a' agregado a lista temporal de variables en ámbito: global
Agregando ID 'b' a lista temporal en ámbito: global
'b' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'a' agregada de tipo Type.INT en dirección 5000
Variable global 'b' agregada de tipo Type.INT en dirección 5001
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'resultado' agregada de tipo Type.INT en dirección 5002
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa negativos iniciado, ámbito reiniciado a global
Programa negativos completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: main - Dirección de Inicio: 1
----------------------------------------------------------------------
0: (goto, None, None, 1)
        saltar al cuádruplo 1
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (*, 20000, 20001, 15000)
        multiplicar constante(-1) y constante(5), guardar resultado en dir:15000
----------------------------------------------------------------------
2: (=, 15000, None, 5000)
        asignar valor de dir:15000 a a (global)
----------------------------------------------------------------------
3: (=, 20002, None, 5001)
        asignar valor de constante(3) a b (global)
----------------------------------------------------------------------
4: (+, 5000, 5001, 15001)
        sumar a (global) y b (global), guardar resultado en dir:15001
----------------------------------------------------------------------
5: (=, 15001, None, 5002)
        asignar valor de dir:15001 a resultado (global)
----------------------------------------------------------------------
6: (print, Resultado con negativos: , None, None)
        imprimir valor dir:Resultado con negativos: 
----------------------------------------------------------------------
7: (print, 5002, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
8: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 1)
  Salto a: 1
IP: 1 -> Ejecutando: (*, 20000, 20001, 15000)
  Aritmética: -1 * 5 = -5
IP: 2 -> Ejecutando: (=, 15000, None, 5000)
  Asignación: direccion[5000] = -5
IP: 3 -> Ejecutando: (=, 20002, None, 5001)
  Asignación: direccion[5001] = 3
IP: 4 -> Ejecutando: (+, 5000, 5001, 15001)
  Aritmética: -5 + 3 = -2
IP: 5 -> Ejecutando: (=, 15001, None, 5002)
  Asignación: direccion[5002] = -2
IP: 6 -> Ejecutando: (print, Resultado con negativos: , None, None)
OUTPUT: Resultado con negativos: 
IP: 7 -> Ejecutando: (print, 5002, None, None)
OUTPUT: -2
IP: 8 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: -5
  [5001]: 3
  [5002]: -2
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: -5
  [15001]: -2
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
Constantes Enteras (20000-20499):
  [20000]: -1
  [20001]: 5
  [20002]: 3
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - -2

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 7] Factorial con Función
------------------------------------------------------------
CÓDIGO:
 1: program factorial_funcion;
 2: var
 3:     numero, resultado : int;
 4: 
 5: void calcular_factorial(n : int)
 6: [
 7:     var factorial, i : int;
 8:     {
 9:         factorial = 1;
10:         i = 1;
11:         
12:         print("Calculando factorial de ", n);
13:         
14:         while (i < n + 1) do {
15:             factorial = factorial * i;
16:             print("Paso ", i, ": ", factorial);
17:             i = i + 1;
18:         };
19:         
20:         print("Factorial de ", n, " es: ", factorial);
21:     }
22: ];
23: 
24: main {
25:     numero = 5;
26:     calcular_factorial(numero);
27:     
28:     calcular_factorial(4);
29:     calcular_factorial(6);
30: }
31: end

SALIDA OBTENIDA:
Agregando ID 'numero' a lista temporal en ámbito: global
'numero' agregado a lista temporal de variables en ámbito: global
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'numero' agregada de tipo Type.INT en dirección 5000
Variable global 'resultado' agregada de tipo Type.INT en dirección 5001
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: calcular_factorial, pila de ámbitos actual: ['global', 'calcular_factorial']
Función 'calcular_factorial' declarada con tipo de retorno Type.VOID, ámbito cambiado a: calcular_factorial
Parámetro 'n' agregado de tipo Type.INT en dirección 11000 a función 'calcular_factorial'
Agregando ID 'factorial' a lista temporal en ámbito: calcular_factorial
'factorial' agregado a lista temporal de variables en ámbito: calcular_factorial
Agregando ID 'i' a lista temporal en ámbito: calcular_factorial
'i' agregado a lista temporal de variables en ámbito: calcular_factorial
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: calcular_factorial
Variable local 'factorial' agregada de tipo Type.INT en dirección 11001 a función 'calcular_factorial'
Variable local 'i' agregada de tipo Type.INT en dirección 11002 a función 'calcular_factorial'
Iniciando declaración de variables en ámbito 'calcular_factorial'
Ámbito removido: calcular_factorial, ámbito actual es ahora: global
Declaración de función 'calcular_factorial' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa factorial_funcion iniciado, ámbito reiniciado a global
Programa factorial_funcion completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: calcular_factorial - Dirección de Inicio: 1
Función: main - Dirección de Inicio: 22
----------------------------------------------------------------------
0: (goto, None, None, 22)
        saltar al cuádruplo 22
----------------------------------------------------------------------

==================== FUNCIÓN: calcular_factorial ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 11001)
        asignar valor de constante(1) a dir:11001
----------------------------------------------------------------------
2: (=, 20000, None, 11002)
        asignar valor de constante(1) a dir:11002
----------------------------------------------------------------------
3: (print, Calculando factorial de , None, None)
        imprimir valor dir:Calculando factorial de 
----------------------------------------------------------------------
4: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
5: (+, 11000, 20000, 15000)
        sumar dir:11000 y constante(1), guardar resultado en dir:15000
----------------------------------------------------------------------
6: (<, 11002, 15000, 19000)
        comparar si dir:11002 es menor que dir:15000, guardar resultado booleano en dir:19000
----------------------------------------------------------------------
7: (gotof, 19000, None, 17)
        si dir:19000 es falso, saltar al cuádruplo 17
----------------------------------------------------------------------
8: (*, 11001, 11002, 15001)
        multiplicar dir:11001 y dir:11002, guardar resultado en dir:15001
----------------------------------------------------------------------
9: (=, 15001, None, 11001)
        asignar valor de dir:15001 a dir:11001
----------------------------------------------------------------------
10: (print, Paso , None, None)
        imprimir valor dir:Paso 
----------------------------------------------------------------------
11: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
12: (print, : , None, None)
        imprimir valor dir:: 
----------------------------------------------------------------------
13: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
14: (+, 11002, 20000, 15002)
        sumar dir:11002 y constante(1), guardar resultado en dir:15002
----------------------------------------------------------------------
15: (=, 15002, None, 11002)
        asignar valor de dir:15002 a dir:11002
----------------------------------------------------------------------
16: (goto, None, None, 5)
        saltar al cuádruplo 5
----------------------------------------------------------------------
17: (print, Factorial de , None, None)
        imprimir valor dir:Factorial de 
----------------------------------------------------------------------
18: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
19: (print,  es: , None, None)
        imprimir valor dir: es: 
----------------------------------------------------------------------
20: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
21: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE calcular_factorial ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 22
----------------------------------------------------------------------
22: (=, 20001, None, 5000)
        asignar valor de constante(5) a numero (global)
----------------------------------------------------------------------
23: (ERA, calcular_factorial, None, None)
        realizar operación ERA con operando dir:calcular_factorial
----------------------------------------------------------------------
24: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos numero (global), dir:par1, resultado en None
----------------------------------------------------------------------
25: (GOSUB, calcular_factorial, None, None)
        realizar operación GOSUB con operando dir:calcular_factorial
----------------------------------------------------------------------
26: (ERA, calcular_factorial, None, None)
        realizar operación ERA con operando dir:calcular_factorial
----------------------------------------------------------------------
27: (parámetro, 20002, par1, None)
        realizar operación parámetro con operandos constante(4), dir:par1, resultado en None
----------------------------------------------------------------------
28: (GOSUB, calcular_factorial, None, None)
        realizar operación GOSUB con operando dir:calcular_factorial
----------------------------------------------------------------------
29: (ERA, calcular_factorial, None, None)
        realizar operación ERA con operando dir:calcular_factorial
----------------------------------------------------------------------
30: (parámetro, 20003, par1, None)
        realizar operación parámetro con operandos constante(6), dir:par1, resultado en None
----------------------------------------------------------------------
31: (GOSUB, calcular_factorial, None, None)
        realizar operación GOSUB con operando dir:calcular_factorial
----------------------------------------------------------------------
32: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 22)
  Salto a: 22
IP: 22 -> Ejecutando: (=, 20001, None, 5000)
  Asignación: direccion[5000] = 5
IP: 23 -> Ejecutando: (ERA, calcular_factorial, None, None)
  ERA: Reservando espacio para función 'calcular_factorial'
IP: 24 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 5 -> posición 1
IP: 25 -> Ejecutando: (GOSUB, calcular_factorial, None, None)
    Asignando parámetro n (addr: 11000) = 5
  GOSUB: Llamando función 'calcular_factorial' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11001)
  Asignación: direccion[11001] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 3 -> Ejecutando: (print, Calculando factorial de , None, None)
OUTPUT: Calculando factorial de 
IP: 4 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 1 < 6 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 1 = 1
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 1
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 2 < 6 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 2 = 2
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 3 < 6 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 2 * 3 = 6
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 6
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 6
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 4
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 4 < 6 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 6 * 4 = 24
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 24
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 4
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 24
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 5
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 5 < 6 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 24 * 5 = 120
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 120
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 5
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 120
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 5 + 1 = 6
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 6
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 6 < 6 = False
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  Salto condicional a: 17 (condición falsa)
IP: 17 -> Ejecutando: (print, Factorial de , None, None)
OUTPUT: Factorial de 
IP: 18 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 5
IP: 19 -> Ejecutando: (print,  es: , None, None)
OUTPUT:  es: 
IP: 20 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 120
IP: 21 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 26
IP: 26 -> Ejecutando: (ERA, calcular_factorial, None, None)
  ERA: Reservando espacio para función 'calcular_factorial'
IP: 27 -> Ejecutando: (parámetro, 20002, par1, None)
  Parámetro: 4 -> posición 1
IP: 28 -> Ejecutando: (GOSUB, calcular_factorial, None, None)
    Asignando parámetro n (addr: 11000) = 4
  GOSUB: Llamando función 'calcular_factorial' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11001)
  Asignación: direccion[11001] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 3 -> Ejecutando: (print, Calculando factorial de , None, None)
OUTPUT: Calculando factorial de 
IP: 4 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 4
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 1 < 5 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 1 = 1
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 1
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 2 < 5 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 2 = 2
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 3 < 5 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 2 * 3 = 6
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 6
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 6
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 4
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 4 < 5 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 6 * 4 = 24
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 24
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 4
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 24
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 5
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 5 < 5 = False
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  Salto condicional a: 17 (condición falsa)
IP: 17 -> Ejecutando: (print, Factorial de , None, None)
OUTPUT: Factorial de 
IP: 18 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 4
IP: 19 -> Ejecutando: (print,  es: , None, None)
OUTPUT:  es: 
IP: 20 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 24
IP: 21 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 29
IP: 29 -> Ejecutando: (ERA, calcular_factorial, None, None)
  ERA: Reservando espacio para función 'calcular_factorial'
IP: 30 -> Ejecutando: (parámetro, 20003, par1, None)
  Parámetro: 6 -> posición 1
IP: 31 -> Ejecutando: (GOSUB, calcular_factorial, None, None)
    Asignando parámetro n (addr: 11000) = 6
  GOSUB: Llamando función 'calcular_factorial' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11001)
  Asignación: direccion[11001] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 3 -> Ejecutando: (print, Calculando factorial de , None, None)
OUTPUT: Calculando factorial de 
IP: 4 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 6
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 1 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 1 = 1
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 1
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 2 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 1 * 2 = 2
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 3 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 2 * 3 = 6
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 6
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 6
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 4
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 4 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 6 * 4 = 24
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 24
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 4
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 24
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 5
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 5 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 24 * 5 = 120
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 120
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 5
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 120
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 5 + 1 = 6
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 6
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 6 < 7 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (*, 11001, 11002, 15001)
  Aritmética: 120 * 6 = 720
IP: 9 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 720
IP: 10 -> Ejecutando: (print, Paso , None, None)
OUTPUT: Paso 
IP: 11 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 6
IP: 12 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 720
IP: 14 -> Ejecutando: (+, 11002, 20000, 15002)
  Aritmética: 6 + 1 = 7
IP: 15 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 7
IP: 16 -> Ejecutando: (goto, None, None, 5)
  Salto a: 5
IP: 5 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 6 + 1 = 7
IP: 6 -> Ejecutando: (<, 11002, 15000, 19000)
  Comparación: 7 < 7 = False
IP: 7 -> Ejecutando: (gotof, 19000, None, 17)
  Salto condicional a: 17 (condición falsa)
IP: 17 -> Ejecutando: (print, Factorial de , None, None)
OUTPUT: Factorial de 
IP: 18 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 6
IP: 19 -> Ejecutando: (print,  es: , None, None)
OUTPUT:  es: 
IP: 20 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 720
IP: 21 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 32
IP: 32 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 5
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 7
  [15001]: 720
  [15002]: 7
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
Constantes Enteras (20000-20499):
  [20000]: 1
  [20001]: 5
  [20002]: 4
  [20003]: 6
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - Calculando factorial de
  - 5
  - Paso
  - 1
  - :
  - 1
  - Paso
  - 2
  - :
  - 2
  - Paso
  - 3
  - :
  - 6
  - Paso
  - 4
  - :
  - 24
  - Paso
  - 5
  - :
  - 120
  - Factorial de
  - 5
  - es:
  - 120
  - Calculando factorial de
  - 4
  - Factorial de
  - 4
  - es:
  - 24
  - Calculando factorial de
  - 6
  - Factorial de
  - 6
  - es:
  - 720

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 8] Fibonacci con Función
------------------------------------------------------------
CÓDIGO:
 1: program fibonacci_funcion;
 2: var
 3:     cantidad : int;
 4: 
 5: void generar_fibonacci(n : int)
 6: [
 7:     var i, fib1, fib2, siguiente : int;
 8:     {
 9:         fib1 = 0;
10:         fib2 = 1;
11:         
12:         print("Serie de Fibonacci de ", n, " términos:");
13:         
14:         if (n > 2) {
15:             print("F(1) = ", fib1);
16:         };
17:         
18:         if (n > 3) {
19:             print("F(2) = ", fib2);
20:         };
21:         
22:         i = 3;
23:         while (i < n + 1) do {
24:             siguiente = fib1 + fib2;
25:             print("F(", i, ") = ", siguiente);
26:             fib1 = fib2;
27:             fib2 = siguiente;
28:             i = i + 1;
29:         };
30:         
31:         print("Serie completada");
32:     }
33: ];
34: 
35: void mostrar_fibonacci_hasta(limite : int)
36: [
37:     var fib1, fib2, siguiente : int;
38:     {
39:         fib1 = 0;
40:         fib2 = 1;
41:         
42:         print("Fibonacci hasta ", limite, ":");
43:         print(fib1);
44:         
45:         if (fib2 < limite + 1) {
46:             print(fib2);
47:         };
48:         
49:         siguiente = fib1 + fib2;
50:         while (siguiente < limite + 1) do {
51:             print(siguiente);
52:             fib1 = fib2;
53:             fib2 = siguiente;
54:             siguiente = fib1 + fib2;
55:         };
56:     }
57: ];
58: 
59: main {
60:     cantidad = 7;
61:     generar_fibonacci(cantidad);
62:     
63:     mostrar_fibonacci_hasta(20);
64: }
65: end

SALIDA OBTENIDA:
Agregando ID 'cantidad' a lista temporal en ámbito: global
'cantidad' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'cantidad' agregada de tipo Type.INT en dirección 5000
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: generar_fibonacci, pila de ámbitos actual: ['global', 'generar_fibonacci']
Función 'generar_fibonacci' declarada con tipo de retorno Type.VOID, ámbito cambiado a: generar_fibonacci
Parámetro 'n' agregado de tipo Type.INT en dirección 11000 a función 'generar_fibonacci'
Agregando ID 'i' a lista temporal en ámbito: generar_fibonacci
'i' agregado a lista temporal de variables en ámbito: generar_fibonacci
Agregando ID 'fib1' a lista temporal en ámbito: generar_fibonacci
'fib1' agregado a lista temporal de variables en ámbito: generar_fibonacci
Agregando ID 'fib2' a lista temporal en ámbito: generar_fibonacci
'fib2' agregado a lista temporal de variables en ámbito: generar_fibonacci
Agregando ID 'siguiente' a lista temporal en ámbito: generar_fibonacci
'siguiente' agregado a lista temporal de variables en ámbito: generar_fibonacci
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: generar_fibonacci
Variable local 'i' agregada de tipo Type.INT en dirección 11001 a función 'generar_fibonacci'
Variable local 'fib1' agregada de tipo Type.INT en dirección 11002 a función 'generar_fibonacci'
Variable local 'fib2' agregada de tipo Type.INT en dirección 11003 a función 'generar_fibonacci'
Variable local 'siguiente' agregada de tipo Type.INT en dirección 11004 a función 'generar_fibonacci'
Iniciando declaración de variables en ámbito 'generar_fibonacci'
Ámbito removido: generar_fibonacci, ámbito actual es ahora: global
Declaración de función 'generar_fibonacci' terminada, regresado al ámbito: global
Ámbito agregado: mostrar_fibonacci_hasta, pila de ámbitos actual: ['global', 'mostrar_fibonacci_hasta']
Función 'mostrar_fibonacci_hasta' declarada con tipo de retorno Type.VOID, ámbito cambiado a: mostrar_fibonacci_hasta
Parámetro 'limite' agregado de tipo Type.INT en dirección 11005 a función 'mostrar_fibonacci_hasta'
Agregando ID 'fib1' a lista temporal en ámbito: mostrar_fibonacci_hasta
'fib1' agregado a lista temporal de variables en ámbito: mostrar_fibonacci_hasta
Agregando ID 'fib2' a lista temporal en ámbito: mostrar_fibonacci_hasta
'fib2' agregado a lista temporal de variables en ámbito: mostrar_fibonacci_hasta
Agregando ID 'siguiente' a lista temporal en ámbito: mostrar_fibonacci_hasta
'siguiente' agregado a lista temporal de variables en ámbito: mostrar_fibonacci_hasta
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: mostrar_fibonacci_hasta
Variable local 'fib1' agregada de tipo Type.INT en dirección 11006 a función 'mostrar_fibonacci_hasta'
Variable local 'fib2' agregada de tipo Type.INT en dirección 11007 a función 'mostrar_fibonacci_hasta'
Variable local 'siguiente' agregada de tipo Type.INT en dirección 11008 a función 'mostrar_fibonacci_hasta'
Iniciando declaración de variables en ámbito 'mostrar_fibonacci_hasta'
Ámbito removido: mostrar_fibonacci_hasta, ámbito actual es ahora: global
Declaración de función 'mostrar_fibonacci_hasta' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa fibonacci_funcion iniciado, ámbito reiniciado a global
Programa fibonacci_funcion completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: generar_fibonacci - Dirección de Inicio: 1
Función: mostrar_fibonacci_hasta - Dirección de Inicio: 33
Función: main - Dirección de Inicio: 56
----------------------------------------------------------------------
0: (goto, None, None, 56)
        saltar al cuádruplo 56
----------------------------------------------------------------------

==================== FUNCIÓN: generar_fibonacci ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 11002)
        asignar valor de constante(0) a dir:11002
----------------------------------------------------------------------
2: (=, 20001, None, 11003)
        asignar valor de constante(1) a dir:11003
----------------------------------------------------------------------
3: (print, Serie de Fibonacci de , None, None)
        imprimir valor dir:Serie de Fibonacci de 
----------------------------------------------------------------------
4: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
5: (print,  términos:, None, None)
        imprimir valor dir: términos:
----------------------------------------------------------------------
6: (>, 11000, 20002, 19000)
        comparar si dir:11000 es mayor que constante(2), guardar resultado booleano en dir:19000
----------------------------------------------------------------------
7: (gotof, 19000, None, 11)
        si dir:19000 es falso, saltar al cuádruplo 11
----------------------------------------------------------------------
8: (print, F(1) = , None, None)
        imprimir valor dir:F(1) = 
----------------------------------------------------------------------
9: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
10: (goto, None, None, 11)
        saltar al cuádruplo 11
----------------------------------------------------------------------
11: (>, 11000, 20003, 19001)
        comparar si dir:11000 es mayor que constante(3), guardar resultado booleano en dir:19001
----------------------------------------------------------------------
12: (gotof, 19001, None, 16)
        si dir:19001 es falso, saltar al cuádruplo 16
----------------------------------------------------------------------
13: (print, F(2) = , None, None)
        imprimir valor dir:F(2) = 
----------------------------------------------------------------------
14: (print, 11003, None, None)
        imprimir valor dir:11003
----------------------------------------------------------------------
15: (goto, None, None, 16)
        saltar al cuádruplo 16
----------------------------------------------------------------------
16: (=, 20003, None, 11001)
        asignar valor de constante(3) a dir:11001
----------------------------------------------------------------------
17: (+, 11000, 20001, 15000)
        sumar dir:11000 y constante(1), guardar resultado en dir:15000
----------------------------------------------------------------------
18: (<, 11001, 15000, 19002)
        comparar si dir:11001 es menor que dir:15000, guardar resultado booleano en dir:19002
----------------------------------------------------------------------
19: (gotof, 19002, None, 31)
        si dir:19002 es falso, saltar al cuádruplo 31
----------------------------------------------------------------------
20: (+, 11002, 11003, 15001)
        sumar dir:11002 y dir:11003, guardar resultado en dir:15001
----------------------------------------------------------------------
21: (=, 15001, None, 11004)
        asignar valor de dir:15001 a dir:11004
----------------------------------------------------------------------
22: (print, F(, None, None)
        imprimir valor dir:F(
----------------------------------------------------------------------
23: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
24: (print, ) = , None, None)
        imprimir valor dir:) = 
----------------------------------------------------------------------
25: (print, 11004, None, None)
        imprimir valor dir:11004
----------------------------------------------------------------------
26: (=, 11003, None, 11002)
        asignar valor de dir:11003 a dir:11002
----------------------------------------------------------------------
27: (=, 11004, None, 11003)
        asignar valor de dir:11004 a dir:11003
----------------------------------------------------------------------
28: (+, 11001, 20001, 15002)
        sumar dir:11001 y constante(1), guardar resultado en dir:15002
----------------------------------------------------------------------
29: (=, 15002, None, 11001)
        asignar valor de dir:15002 a dir:11001
----------------------------------------------------------------------
30: (goto, None, None, 17)
        saltar al cuádruplo 17
----------------------------------------------------------------------
31: (print, Serie completada, None, None)
        imprimir valor dir:Serie completada
----------------------------------------------------------------------
32: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE generar_fibonacci ====================
----------------------------------------------------------------------

==================== FUNCIÓN: mostrar_fibonacci_hasta ====================
Inicia en el cuádruplo 33
----------------------------------------------------------------------
33: (=, 20000, None, 11006)
        asignar valor de constante(0) a dir:11006
----------------------------------------------------------------------
34: (=, 20001, None, 11007)
        asignar valor de constante(1) a dir:11007
----------------------------------------------------------------------
35: (print, Fibonacci hasta , None, None)
        imprimir valor dir:Fibonacci hasta 
----------------------------------------------------------------------
36: (print, 11005, None, None)
        imprimir valor dir:11005
----------------------------------------------------------------------
37: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
38: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
39: (+, 11005, 20001, 15003)
        sumar dir:11005 y constante(1), guardar resultado en dir:15003
----------------------------------------------------------------------
40: (<, 11007, 15003, 19003)
        comparar si dir:11007 es menor que dir:15003, guardar resultado booleano en dir:19003
----------------------------------------------------------------------
41: (gotof, 19003, None, 44)
        si dir:19003 es falso, saltar al cuádruplo 44
----------------------------------------------------------------------
42: (print, 11007, None, None)
        imprimir valor dir:11007
----------------------------------------------------------------------
43: (goto, None, None, 44)
        saltar al cuádruplo 44
----------------------------------------------------------------------
44: (+, 11006, 11007, 15004)
        sumar dir:11006 y dir:11007, guardar resultado en dir:15004
----------------------------------------------------------------------
45: (=, 15004, None, 11008)
        asignar valor de dir:15004 a dir:11008
----------------------------------------------------------------------
46: (+, 11005, 20001, 15005)
        sumar dir:11005 y constante(1), guardar resultado en dir:15005
----------------------------------------------------------------------
47: (<, 11008, 15005, 19004)
        comparar si dir:11008 es menor que dir:15005, guardar resultado booleano en dir:19004
----------------------------------------------------------------------
48: (gotof, 19004, None, 55)
        si dir:19004 es falso, saltar al cuádruplo 55
----------------------------------------------------------------------
49: (print, 11008, None, None)
        imprimir valor dir:11008
----------------------------------------------------------------------
50: (=, 11007, None, 11006)
        asignar valor de dir:11007 a dir:11006
----------------------------------------------------------------------
51: (=, 11008, None, 11007)
        asignar valor de dir:11008 a dir:11007
----------------------------------------------------------------------
52: (+, 11006, 11007, 15006)
        sumar dir:11006 y dir:11007, guardar resultado en dir:15006
----------------------------------------------------------------------
53: (=, 15006, None, 11008)
        asignar valor de dir:15006 a dir:11008
----------------------------------------------------------------------
54: (goto, None, None, 46)
        saltar al cuádruplo 46
----------------------------------------------------------------------
55: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE mostrar_fibonacci_hasta ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 56
----------------------------------------------------------------------
56: (=, 20004, None, 5000)
        asignar valor de constante(7) a cantidad (global)
----------------------------------------------------------------------
57: (ERA, generar_fibonacci, None, None)
        realizar operación ERA con operando dir:generar_fibonacci
----------------------------------------------------------------------
58: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos cantidad (global), dir:par1, resultado en None
----------------------------------------------------------------------
59: (GOSUB, generar_fibonacci, None, None)
        realizar operación GOSUB con operando dir:generar_fibonacci
----------------------------------------------------------------------
60: (ERA, mostrar_fibonacci_hasta, None, None)
        realizar operación ERA con operando dir:mostrar_fibonacci_hasta
----------------------------------------------------------------------
61: (parámetro, 20005, par1, None)
        realizar operación parámetro con operandos constante(20), dir:par1, resultado en None
----------------------------------------------------------------------
62: (GOSUB, mostrar_fibonacci_hasta, None, None)
        realizar operación GOSUB con operando dir:mostrar_fibonacci_hasta
----------------------------------------------------------------------
63: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 56)
  Salto a: 56
IP: 56 -> Ejecutando: (=, 20004, None, 5000)
  Asignación: direccion[5000] = 7
IP: 57 -> Ejecutando: (ERA, generar_fibonacci, None, None)
  ERA: Reservando espacio para función 'generar_fibonacci'
IP: 58 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 7 -> posición 1
IP: 59 -> Ejecutando: (GOSUB, generar_fibonacci, None, None)
    Asignando parámetro n (addr: 11000) = 7
  GOSUB: Llamando función 'generar_fibonacci' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 0
IP: 2 -> Ejecutando: (=, 20001, None, 11003)
  Asignación: direccion[11003] = 1
IP: 3 -> Ejecutando: (print, Serie de Fibonacci de , None, None)
OUTPUT: Serie de Fibonacci de 
IP: 4 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 7
IP: 5 -> Ejecutando: (print,  términos:, None, None)
OUTPUT:  términos:
IP: 6 -> Ejecutando: (>, 11000, 20002, 19000)
  Comparación: 7 > 2 = True
IP: 7 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 8 -> Ejecutando: (print, F(1) = , None, None)
OUTPUT: F(1) = 
IP: 9 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 0
IP: 10 -> Ejecutando: (goto, None, None, 11)
  Salto a: 11
IP: 11 -> Ejecutando: (>, 11000, 20003, 19001)
  Comparación: 7 > 3 = True
IP: 12 -> Ejecutando: (gotof, 19001, None, 16)
  No hay salto (condición verdadera)
IP: 13 -> Ejecutando: (print, F(2) = , None, None)
OUTPUT: F(2) = 
IP: 14 -> Ejecutando: (print, 11003, None, None)
OUTPUT: 1
IP: 15 -> Ejecutando: (goto, None, None, 16)
  Salto a: 16
IP: 16 -> Ejecutando: (=, 20003, None, 11001)
  Asignación: direccion[11001] = 3
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 3 < 8 = True
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  No hay salto (condición verdadera)
IP: 20 -> Ejecutando: (+, 11002, 11003, 15001)
  Aritmética: 0 + 1 = 1
IP: 21 -> Ejecutando: (=, 15001, None, 11004)
  Asignación: direccion[11004] = 1
IP: 22 -> Ejecutando: (print, F(, None, None)
OUTPUT: F(
IP: 23 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 3
IP: 24 -> Ejecutando: (print, ) = , None, None)
OUTPUT: ) = 
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 1
IP: 26 -> Ejecutando: (=, 11003, None, 11002)
  Asignación: direccion[11002] = 1
IP: 27 -> Ejecutando: (=, 11004, None, 11003)
  Asignación: direccion[11003] = 1
IP: 28 -> Ejecutando: (+, 11001, 20001, 15002)
  Aritmética: 3 + 1 = 4
IP: 29 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 4
IP: 30 -> Ejecutando: (goto, None, None, 17)
  Salto a: 17
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 4 < 8 = True
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  No hay salto (condición verdadera)
IP: 20 -> Ejecutando: (+, 11002, 11003, 15001)
  Aritmética: 1 + 1 = 2
IP: 21 -> Ejecutando: (=, 15001, None, 11004)
  Asignación: direccion[11004] = 2
IP: 22 -> Ejecutando: (print, F(, None, None)
OUTPUT: F(
IP: 23 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 4
IP: 24 -> Ejecutando: (print, ) = , None, None)
OUTPUT: ) = 
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 2
IP: 26 -> Ejecutando: (=, 11003, None, 11002)
  Asignación: direccion[11002] = 1
IP: 27 -> Ejecutando: (=, 11004, None, 11003)
  Asignación: direccion[11003] = 2
IP: 28 -> Ejecutando: (+, 11001, 20001, 15002)
  Aritmética: 4 + 1 = 5
IP: 29 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 5
IP: 30 -> Ejecutando: (goto, None, None, 17)
  Salto a: 17
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 5 < 8 = True
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  No hay salto (condición verdadera)
IP: 20 -> Ejecutando: (+, 11002, 11003, 15001)
  Aritmética: 1 + 2 = 3
IP: 21 -> Ejecutando: (=, 15001, None, 11004)
  Asignación: direccion[11004] = 3
IP: 22 -> Ejecutando: (print, F(, None, None)
OUTPUT: F(
IP: 23 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 5
IP: 24 -> Ejecutando: (print, ) = , None, None)
OUTPUT: ) = 
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 3
IP: 26 -> Ejecutando: (=, 11003, None, 11002)
  Asignación: direccion[11002] = 2
IP: 27 -> Ejecutando: (=, 11004, None, 11003)
  Asignación: direccion[11003] = 3
IP: 28 -> Ejecutando: (+, 11001, 20001, 15002)
  Aritmética: 5 + 1 = 6
IP: 29 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 6
IP: 30 -> Ejecutando: (goto, None, None, 17)
  Salto a: 17
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 6 < 8 = True
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  No hay salto (condición verdadera)
IP: 20 -> Ejecutando: (+, 11002, 11003, 15001)
  Aritmética: 2 + 3 = 5
IP: 21 -> Ejecutando: (=, 15001, None, 11004)
  Asignación: direccion[11004] = 5
IP: 22 -> Ejecutando: (print, F(, None, None)
OUTPUT: F(
IP: 23 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 6
IP: 24 -> Ejecutando: (print, ) = , None, None)
OUTPUT: ) = 
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 5
IP: 26 -> Ejecutando: (=, 11003, None, 11002)
  Asignación: direccion[11002] = 3
IP: 27 -> Ejecutando: (=, 11004, None, 11003)
  Asignación: direccion[11003] = 5
IP: 28 -> Ejecutando: (+, 11001, 20001, 15002)
  Aritmética: 6 + 1 = 7
IP: 29 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 7
IP: 30 -> Ejecutando: (goto, None, None, 17)
  Salto a: 17
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 7 < 8 = True
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  No hay salto (condición verdadera)
IP: 20 -> Ejecutando: (+, 11002, 11003, 15001)
  Aritmética: 3 + 5 = 8
IP: 21 -> Ejecutando: (=, 15001, None, 11004)
  Asignación: direccion[11004] = 8
IP: 22 -> Ejecutando: (print, F(, None, None)
OUTPUT: F(
IP: 23 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 7
IP: 24 -> Ejecutando: (print, ) = , None, None)
OUTPUT: ) = 
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 8
IP: 26 -> Ejecutando: (=, 11003, None, 11002)
  Asignación: direccion[11002] = 5
IP: 27 -> Ejecutando: (=, 11004, None, 11003)
  Asignación: direccion[11003] = 8
IP: 28 -> Ejecutando: (+, 11001, 20001, 15002)
  Aritmética: 7 + 1 = 8
IP: 29 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 8
IP: 30 -> Ejecutando: (goto, None, None, 17)
  Salto a: 17
IP: 17 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 7 + 1 = 8
IP: 18 -> Ejecutando: (<, 11001, 15000, 19002)
  Comparación: 8 < 8 = False
IP: 19 -> Ejecutando: (gotof, 19002, None, 31)
  Salto condicional a: 31 (condición falsa)
IP: 31 -> Ejecutando: (print, Serie completada, None, None)
OUTPUT: Serie completada
IP: 32 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 60
IP: 60 -> Ejecutando: (ERA, mostrar_fibonacci_hasta, None, None)
  ERA: Reservando espacio para función 'mostrar_fibonacci_hasta'
IP: 61 -> Ejecutando: (parámetro, 20005, par1, None)
  Parámetro: 20 -> posición 1
IP: 62 -> Ejecutando: (GOSUB, mostrar_fibonacci_hasta, None, None)
    Asignando parámetro limite (addr: 11005) = 20
  GOSUB: Llamando función 'mostrar_fibonacci_hasta' en dirección 33
IP: 33 -> Ejecutando: (=, 20000, None, 11006)
  Asignación: direccion[11006] = 0
IP: 34 -> Ejecutando: (=, 20001, None, 11007)
  Asignación: direccion[11007] = 1
IP: 35 -> Ejecutando: (print, Fibonacci hasta , None, None)
OUTPUT: Fibonacci hasta 
IP: 36 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 20
IP: 37 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 38 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 0
IP: 39 -> Ejecutando: (+, 11005, 20001, 15003)
  Aritmética: 20 + 1 = 21
IP: 40 -> Ejecutando: (<, 11007, 15003, 19003)
  Comparación: 1 < 21 = True
IP: 41 -> Ejecutando: (gotof, 19003, None, 44)
  No hay salto (condición verdadera)
IP: 42 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 1
IP: 43 -> Ejecutando: (goto, None, None, 44)
  Salto a: 44
IP: 44 -> Ejecutando: (+, 11006, 11007, 15004)
  Aritmética: 0 + 1 = 1
IP: 45 -> Ejecutando: (=, 15004, None, 11008)
  Asignación: direccion[11008] = 1
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 1 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 1
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 1
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 1
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 1 + 1 = 2
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 2
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 2 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 2
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 1
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 2
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 1 + 2 = 3
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 3
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 3 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 3
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 2
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 3
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 2 + 3 = 5
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 5
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 5 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 5
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 3
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 5
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 3 + 5 = 8
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 8
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 8 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 8
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 5
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 8
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 5 + 8 = 13
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 13
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 13 < 21 = True
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  No hay salto (condición verdadera)
IP: 49 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 13
IP: 50 -> Ejecutando: (=, 11007, None, 11006)
  Asignación: direccion[11006] = 8
IP: 51 -> Ejecutando: (=, 11008, None, 11007)
  Asignación: direccion[11007] = 13
IP: 52 -> Ejecutando: (+, 11006, 11007, 15006)
  Aritmética: 8 + 13 = 21
IP: 53 -> Ejecutando: (=, 15006, None, 11008)
  Asignación: direccion[11008] = 21
IP: 54 -> Ejecutando: (goto, None, None, 46)
  Salto a: 46
IP: 46 -> Ejecutando: (+, 11005, 20001, 15005)
  Aritmética: 20 + 1 = 21
IP: 47 -> Ejecutando: (<, 11008, 15005, 19004)
  Comparación: 21 < 21 = False
IP: 48 -> Ejecutando: (gotof, 19004, None, 55)
  Salto condicional a: 55 (condición falsa)
IP: 55 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 63
IP: 63 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 7
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 8
  [15001]: 8
  [15002]: 8
  [15003]: 21
  [15004]: 1
  [15005]: 21
  [15006]: 21
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: True
  [19001]: True
  [19002]: False
  [19003]: True
  [19004]: False
Constantes Enteras (20000-20499):
  [20000]: 0
  [20001]: 1
  [20002]: 2
  [20003]: 3
  [20004]: 7
  [20005]: 20
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - Serie de Fibonacci de
  - 7
  - términos:
  - F(1) =
  - 0
  - F(2) =
  - 1
  - F(
  - 3
  - ) =
  - 1
  - F(
  - 4
  - ) =
  - 2
  - F(
  - 5
  - ) =
  - 3
  - F(
  - 6
  - ) =
  - 5
  - F(
  - 7
  - ) =
  - 8
  - Serie completada
  - Fibonacci hasta
  - 20
  - 0
  - 1
  - 1
  - 2
  - 3
  - 5
  - 8
  - 13

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 9] Funciones Matemáticas Avanzadas
------------------------------------------------------------
CÓDIGO:
 1: program funciones_matematicas;
 2: var
 3:     num1, num2, resultado : int;
 4: 
 5: void potencia(base : int, exponente : int)
 6: [
 7:     var resultado, i : int;
 8:     {
 9:         resultado = 1;
10:         i = 1;
11:         
12:         while (i < exponente + 1) do {
13:             resultado = resultado * base;
14:             i = i + 1;
15:         };
16:         
17:         print(base, " elevado a ", exponente, " = ", resultado);
18:     }
19: ];
20: 
21: void tabla_multiplicar(numero : int)
22: [
23:     var i, producto : int;
24:     {
25:         print("Tabla del ", numero, ":");
26:         i = 1;
27:         while (i < 11) do {
28:             producto = numero * i;
29:             print(numero, " x ", i, " = ", producto);
30:             i = i + 1;
31:         };
32:     }
33: ];
34: 
35: void mcd(a : float, b : float)
36: [
37:     var temp : float;
38:     {
39:         print("Calculando MCD de ", a, " y ", b);
40:         
41:         while (b != 0) do {
42:             temp = b;
43:             b = a - (a / b) * b;
44:             a = temp;
45:         };
46:         
47:         print("MCD = ", a);
48:     }
49: ];
50: 
51: main {
52:     potencia(2, 5);
53:     potencia(3, 4);
54:     
55:     tabla_multiplicar(7);
56:     
57:     mcd(48, 18);
58: }
59: end

SALIDA OBTENIDA:
Agregando ID 'num1' a lista temporal en ámbito: global
'num1' agregado a lista temporal de variables en ámbito: global
Agregando ID 'num2' a lista temporal en ámbito: global
'num2' agregado a lista temporal de variables en ámbito: global
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'num1' agregada de tipo Type.INT en dirección 5000
Variable global 'num2' agregada de tipo Type.INT en dirección 5001
Variable global 'resultado' agregada de tipo Type.INT en dirección 5002
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: potencia, pila de ámbitos actual: ['global', 'potencia']
Función 'potencia' declarada con tipo de retorno Type.VOID, ámbito cambiado a: potencia
Parámetro 'base' agregado de tipo Type.INT en dirección 11000 a función 'potencia'
Parámetro 'exponente' agregado de tipo Type.INT en dirección 11001 a función 'potencia'
Agregando ID 'resultado' a lista temporal en ámbito: potencia
'resultado' agregado a lista temporal de variables en ámbito: potencia
Agregando ID 'i' a lista temporal en ámbito: potencia
'i' agregado a lista temporal de variables en ámbito: potencia
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: potencia
Variable local 'resultado' agregada de tipo Type.INT en dirección 11002 a función 'potencia'
Variable local 'i' agregada de tipo Type.INT en dirección 11003 a función 'potencia'
Iniciando declaración de variables en ámbito 'potencia'
Ámbito removido: potencia, ámbito actual es ahora: global
Declaración de función 'potencia' terminada, regresado al ámbito: global
Ámbito agregado: tabla_multiplicar, pila de ámbitos actual: ['global', 'tabla_multiplicar']
Función 'tabla_multiplicar' declarada con tipo de retorno Type.VOID, ámbito cambiado a: tabla_multiplicar
Parámetro 'numero' agregado de tipo Type.INT en dirección 11004 a función 'tabla_multiplicar'
Agregando ID 'i' a lista temporal en ámbito: tabla_multiplicar
'i' agregado a lista temporal de variables en ámbito: tabla_multiplicar
Agregando ID 'producto' a lista temporal en ámbito: tabla_multiplicar
'producto' agregado a lista temporal de variables en ámbito: tabla_multiplicar
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: tabla_multiplicar
Variable local 'i' agregada de tipo Type.INT en dirección 11005 a función 'tabla_multiplicar'
Variable local 'producto' agregada de tipo Type.INT en dirección 11006 a función 'tabla_multiplicar'
Iniciando declaración de variables en ámbito 'tabla_multiplicar'
Ámbito removido: tabla_multiplicar, ámbito actual es ahora: global
Declaración de función 'tabla_multiplicar' terminada, regresado al ámbito: global
Ámbito agregado: mcd, pila de ámbitos actual: ['global', 'mcd']
Función 'mcd' declarada con tipo de retorno Type.VOID, ámbito cambiado a: mcd
Parámetro 'a' agregado de tipo Type.FLOAT en dirección 13000 a función 'mcd'
Parámetro 'b' agregado de tipo Type.FLOAT en dirección 13001 a función 'mcd'
Agregando ID 'temp' a lista temporal en ámbito: mcd
'temp' agregado a lista temporal de variables en ámbito: mcd
Tipo actual establecido a Type.FLOAT
Agregando variables a tabla en ámbito: mcd
Variable local 'temp' agregada de tipo Type.FLOAT en dirección 13002 a función 'mcd'
Iniciando declaración de variables en ámbito 'mcd'
Ámbito removido: mcd, ámbito actual es ahora: global
Declaración de función 'mcd' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa funciones_matematicas iniciado, ámbito reiniciado a global
Programa funciones_matematicas completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: potencia - Dirección de Inicio: 1
Función: tabla_multiplicar - Dirección de Inicio: 17
Función: mcd - Dirección de Inicio: 34
Función: main - Dirección de Inicio: 50
----------------------------------------------------------------------
0: (goto, None, None, 50)
        saltar al cuádruplo 50
----------------------------------------------------------------------

==================== FUNCIÓN: potencia ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 11002)
        asignar valor de constante(1) a dir:11002
----------------------------------------------------------------------
2: (=, 20000, None, 11003)
        asignar valor de constante(1) a dir:11003
----------------------------------------------------------------------
3: (+, 11001, 20000, 15000)
        sumar dir:11001 y constante(1), guardar resultado en dir:15000
----------------------------------------------------------------------
4: (<, 11003, 15000, 19000)
        comparar si dir:11003 es menor que dir:15000, guardar resultado booleano en dir:19000
----------------------------------------------------------------------
5: (gotof, 19000, None, 11)
        si dir:19000 es falso, saltar al cuádruplo 11
----------------------------------------------------------------------
6: (*, 11002, 11000, 15001)
        multiplicar dir:11002 y dir:11000, guardar resultado en dir:15001
----------------------------------------------------------------------
7: (=, 15001, None, 11002)
        asignar valor de dir:15001 a dir:11002
----------------------------------------------------------------------
8: (+, 11003, 20000, 15002)
        sumar dir:11003 y constante(1), guardar resultado en dir:15002
----------------------------------------------------------------------
9: (=, 15002, None, 11003)
        asignar valor de dir:15002 a dir:11003
----------------------------------------------------------------------
10: (goto, None, None, 3)
        saltar al cuádruplo 3
----------------------------------------------------------------------
11: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
12: (print,  elevado a , None, None)
        imprimir valor dir: elevado a 
----------------------------------------------------------------------
13: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
14: (print,  = , None, None)
        imprimir valor dir: = 
----------------------------------------------------------------------
15: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
16: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE potencia ====================
----------------------------------------------------------------------

==================== FUNCIÓN: tabla_multiplicar ====================
Inicia en el cuádruplo 17
----------------------------------------------------------------------
17: (print, Tabla del , None, None)
        imprimir valor dir:Tabla del 
----------------------------------------------------------------------
18: (print, 11004, None, None)
        imprimir valor dir:11004
----------------------------------------------------------------------
19: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
20: (=, 20000, None, 11005)
        asignar valor de constante(1) a dir:11005
----------------------------------------------------------------------
21: (<, 11005, 20001, 19001)
        comparar si dir:11005 es menor que constante(11), guardar resultado booleano en dir:19001
----------------------------------------------------------------------
22: (gotof, 19001, None, 33)
        si dir:19001 es falso, saltar al cuádruplo 33
----------------------------------------------------------------------
23: (*, 11004, 11005, 15003)
        multiplicar dir:11004 y dir:11005, guardar resultado en dir:15003
----------------------------------------------------------------------
24: (=, 15003, None, 11006)
        asignar valor de dir:15003 a dir:11006
----------------------------------------------------------------------
25: (print, 11004, None, None)
        imprimir valor dir:11004
----------------------------------------------------------------------
26: (print,  x , None, None)
        imprimir valor dir: x 
----------------------------------------------------------------------
27: (print, 11005, None, None)
        imprimir valor dir:11005
----------------------------------------------------------------------
28: (print,  = , None, None)
        imprimir valor dir: = 
----------------------------------------------------------------------
29: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
30: (+, 11005, 20000, 15004)
        sumar dir:11005 y constante(1), guardar resultado en dir:15004
----------------------------------------------------------------------
31: (=, 15004, None, 11005)
        asignar valor de dir:15004 a dir:11005
----------------------------------------------------------------------
32: (goto, None, None, 21)
        saltar al cuádruplo 21
----------------------------------------------------------------------
33: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE tabla_multiplicar ====================
----------------------------------------------------------------------

==================== FUNCIÓN: mcd ====================
Inicia en el cuádruplo 34
----------------------------------------------------------------------
34: (print, Calculando MCD de , None, None)
        imprimir valor dir:Calculando MCD de 
----------------------------------------------------------------------
35: (print, 13000, None, None)
        imprimir valor dir:13000
----------------------------------------------------------------------
36: (print,  y , None, None)
        imprimir valor dir: y 
----------------------------------------------------------------------
37: (print, 13001, None, None)
        imprimir valor dir:13001
----------------------------------------------------------------------
38: (!=, 13001, 20002, 19002)
        comparar si dir:13001 es diferente de constante(0), guardar resultado booleano en dir:19002
----------------------------------------------------------------------
39: (gotof, 19002, None, 47)
        si dir:19002 es falso, saltar al cuádruplo 47
----------------------------------------------------------------------
40: (=, 13001, None, 13002)
        asignar valor de dir:13001 a dir:13002
----------------------------------------------------------------------
41: (/, 13000, 13001, 17000)
        dividir dir:13000 y dir:13001, guardar resultado en dir:17000
----------------------------------------------------------------------
42: (*, 17000, 13001, 17001)
        multiplicar dir:17000 y dir:13001, guardar resultado en dir:17001
----------------------------------------------------------------------
43: (-, 13000, 17001, 17002)
        restar dir:13000 y dir:17001, guardar resultado en dir:17002
----------------------------------------------------------------------
44: (=, 17002, None, 13001)
        asignar valor de dir:17002 a dir:13001
----------------------------------------------------------------------
45: (=, 13002, None, 13000)
        asignar valor de dir:13002 a dir:13000
----------------------------------------------------------------------
46: (goto, None, None, 38)
        saltar al cuádruplo 38
----------------------------------------------------------------------
47: (print, MCD = , None, None)
        imprimir valor dir:MCD = 
----------------------------------------------------------------------
48: (print, 13000, None, None)
        imprimir valor dir:13000
----------------------------------------------------------------------
49: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE mcd ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 50
----------------------------------------------------------------------
50: (ERA, potencia, None, None)
        realizar operación ERA con operando dir:potencia
----------------------------------------------------------------------
51: (parámetro, 20003, par1, None)
        realizar operación parámetro con operandos constante(2), dir:par1, resultado en None
----------------------------------------------------------------------
52: (parámetro, 20004, par2, None)
        realizar operación parámetro con operandos constante(5), dir:par2, resultado en None
----------------------------------------------------------------------
53: (GOSUB, potencia, None, None)
        realizar operación GOSUB con operando dir:potencia
----------------------------------------------------------------------
54: (ERA, potencia, None, None)
        realizar operación ERA con operando dir:potencia
----------------------------------------------------------------------
55: (parámetro, 20005, par1, None)
        realizar operación parámetro con operandos constante(3), dir:par1, resultado en None
----------------------------------------------------------------------
56: (parámetro, 20006, par2, None)
        realizar operación parámetro con operandos constante(4), dir:par2, resultado en None
----------------------------------------------------------------------
57: (GOSUB, potencia, None, None)
        realizar operación GOSUB con operando dir:potencia
----------------------------------------------------------------------
58: (ERA, tabla_multiplicar, None, None)
        realizar operación ERA con operando temp tabla_multiplicar
----------------------------------------------------------------------
59: (parámetro, 20007, par1, None)
        realizar operación parámetro con operandos constante(7), dir:par1, resultado en None
----------------------------------------------------------------------
60: (GOSUB, tabla_multiplicar, None, None)
        realizar operación GOSUB con operando temp tabla_multiplicar
----------------------------------------------------------------------
61: (ERA, mcd, None, None)
        realizar operación ERA con operando dir:mcd
----------------------------------------------------------------------
62: (parámetro, 20008, par1, None)
        realizar operación parámetro con operandos constante(48), dir:par1, resultado en None
----------------------------------------------------------------------
63: (parámetro, 20009, par2, None)
        realizar operación parámetro con operandos constante(18), dir:par2, resultado en None
----------------------------------------------------------------------
64: (GOSUB, mcd, None, None)
        realizar operación GOSUB con operando dir:mcd
----------------------------------------------------------------------
65: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 50)
  Salto a: 50
IP: 50 -> Ejecutando: (ERA, potencia, None, None)
  ERA: Reservando espacio para función 'potencia'
IP: 51 -> Ejecutando: (parámetro, 20003, par1, None)
  Parámetro: 2 -> posición 1
IP: 52 -> Ejecutando: (parámetro, 20004, par2, None)
  Parámetro: 5 -> posición 2
IP: 53 -> Ejecutando: (GOSUB, potencia, None, None)
    Asignando parámetro base (addr: 11000) = 2
    Asignando parámetro exponente (addr: 11001) = 5
  GOSUB: Llamando función 'potencia' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11003)
  Asignación: direccion[11003] = 1
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 1 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 1 * 2 = 2
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 2
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 2
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 2 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 2 * 2 = 4
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 4
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 3
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 3 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 4 * 2 = 8
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 8
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 4
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 4 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 8 * 2 = 16
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 16
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 5
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 5 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 16 * 2 = 32
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 32
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 5 + 1 = 6
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 6
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 6 < 6 = False
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  Salto condicional a: 11 (condición falsa)
IP: 11 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 2
IP: 12 -> Ejecutando: (print,  elevado a , None, None)
OUTPUT:  elevado a 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 5
IP: 14 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 15 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 32
IP: 16 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 54
IP: 54 -> Ejecutando: (ERA, potencia, None, None)
  ERA: Reservando espacio para función 'potencia'
IP: 55 -> Ejecutando: (parámetro, 20005, par1, None)
  Parámetro: 3 -> posición 1
IP: 56 -> Ejecutando: (parámetro, 20006, par2, None)
  Parámetro: 4 -> posición 2
IP: 57 -> Ejecutando: (GOSUB, potencia, None, None)
    Asignando parámetro base (addr: 11000) = 3
    Asignando parámetro exponente (addr: 11001) = 4
  GOSUB: Llamando función 'potencia' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11003)
  Asignación: direccion[11003] = 1
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 1 < 5 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 1 * 3 = 3
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 3
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 2
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 2 < 5 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 3 * 3 = 9
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 9
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 3
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 3 < 5 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 9 * 3 = 27
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 27
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 4
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 4 < 5 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11000, 15001)
  Aritmética: 27 * 3 = 81
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 81
IP: 8 -> Ejecutando: (+, 11003, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 9 -> Ejecutando: (=, 15002, None, 11003)
  Asignación: direccion[11003] = 5
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11001, 20000, 15000)
  Aritmética: 4 + 1 = 5
IP: 4 -> Ejecutando: (<, 11003, 15000, 19000)
  Comparación: 5 < 5 = False
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  Salto condicional a: 11 (condición falsa)
IP: 11 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 3
IP: 12 -> Ejecutando: (print,  elevado a , None, None)
OUTPUT:  elevado a 
IP: 13 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 4
IP: 14 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 15 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 81
IP: 16 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 58
IP: 58 -> Ejecutando: (ERA, tabla_multiplicar, None, None)
  ERA: Reservando espacio para función 'tabla_multiplicar'
IP: 59 -> Ejecutando: (parámetro, 20007, par1, None)
  Parámetro: 7 -> posición 1
IP: 60 -> Ejecutando: (GOSUB, tabla_multiplicar, None, None)
    Asignando parámetro numero (addr: 11004) = 7
  GOSUB: Llamando función 'tabla_multiplicar' en dirección 17
IP: 17 -> Ejecutando: (print, Tabla del , None, None)
OUTPUT: Tabla del 
IP: 18 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 19 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 20 -> Ejecutando: (=, 20000, None, 11005)
  Asignación: direccion[11005] = 1
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 1 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 1 = 7
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 7
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 1
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 7
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 1 + 1 = 2
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 2
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 2 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 2 = 14
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 14
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 2
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 14
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 2 + 1 = 3
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 3
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 3 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 3 = 21
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 21
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 3
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 21
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 3 + 1 = 4
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 4
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 4 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 4 = 28
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 28
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 4
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 28
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 4 + 1 = 5
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 5
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 5 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 5 = 35
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 35
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 5
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 35
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 5 + 1 = 6
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 6
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 6 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 6 = 42
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 42
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 6
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 42
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 6 + 1 = 7
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 7
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 7 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 7 = 49
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 49
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 7
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 49
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 7 + 1 = 8
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 8
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 8 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 8 = 56
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 56
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 8
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 56
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 8 + 1 = 9
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 9
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 9 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 9 = 63
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 63
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 9
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 63
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 9 + 1 = 10
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 10
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 10 < 11 = True
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  No hay salto (condición verdadera)
IP: 23 -> Ejecutando: (*, 11004, 11005, 15003)
  Aritmética: 7 * 10 = 70
IP: 24 -> Ejecutando: (=, 15003, None, 11006)
  Asignación: direccion[11006] = 70
IP: 25 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 7
IP: 26 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 27 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 10
IP: 28 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 29 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 70
IP: 30 -> Ejecutando: (+, 11005, 20000, 15004)
  Aritmética: 10 + 1 = 11
IP: 31 -> Ejecutando: (=, 15004, None, 11005)
  Asignación: direccion[11005] = 11
IP: 32 -> Ejecutando: (goto, None, None, 21)
  Salto a: 21
IP: 21 -> Ejecutando: (<, 11005, 20001, 19001)
  Comparación: 11 < 11 = False
IP: 22 -> Ejecutando: (gotof, 19001, None, 33)
  Salto condicional a: 33 (condición falsa)
IP: 33 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 61
IP: 61 -> Ejecutando: (ERA, mcd, None, None)
  ERA: Reservando espacio para función 'mcd'
IP: 62 -> Ejecutando: (parámetro, 20008, par1, None)
  Parámetro: 48 -> posición 1
IP: 63 -> Ejecutando: (parámetro, 20009, par2, None)
  Parámetro: 18 -> posición 2
IP: 64 -> Ejecutando: (GOSUB, mcd, None, None)
    Asignando parámetro a (addr: 13000) = 48
    Asignando parámetro b (addr: 13001) = 18
  GOSUB: Llamando función 'mcd' en dirección 34
IP: 34 -> Ejecutando: (print, Calculando MCD de , None, None)
OUTPUT: Calculando MCD de 
IP: 35 -> Ejecutando: (print, 13000, None, None)
OUTPUT: 48.0
IP: 36 -> Ejecutando: (print,  y , None, None)
OUTPUT:  y 
IP: 37 -> Ejecutando: (print, 13001, None, None)
OUTPUT: 18.0
IP: 38 -> Ejecutando: (!=, 13001, 20002, 19002)
Operación no implementada: !=
IP: 39 -> Ejecutando: (gotof, 19002, None, 47)
  Salto condicional a: 47 (condición falsa)
IP: 47 -> Ejecutando: (print, MCD = , None, None)
OUTPUT: MCD = 
IP: 48 -> Ejecutando: (print, 13000, None, None)
OUTPUT: 48.0
IP: 49 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 65
IP: 65 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 5
  [15001]: 81
  [15002]: 5
  [15003]: 70
  [15004]: 11
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
  [19001]: False
Constantes Enteras (20000-20499):
  [20000]: 1
  [20001]: 11
  [20002]: 0
  [20003]: 2
  [20004]: 5
  [20005]: 3
  [20006]: 4
  [20007]: 7
  [20008]: 48
  [20009]: 18
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - 2
  - elevado a
  - 5
  - =
  - 32
  - 3
  - elevado a
  - 4
  - =
  - 81
  - Tabla del
  - 7
  - 7
  - x
  - 1
  - =
  - 7
  - 7
  - x
  - 10
  - =
  - 70
  - Calculando MCD de
  - 48
  - y
  - 18
  - MCD =
  - 6

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 10] Funciones con Parámetros Múltiples
------------------------------------------------------------
CÓDIGO:
 1: program funciones_parametros;
 2: var
 3:     a, b, c : int;
 4:     resultado : float;
 5: 
 6: void operaciones_basicas(x : int, y : int, z : int)
 7: [
 8:     var suma, producto, promedio : int;
 9:     {
10:         suma = x + y + z;
11:         producto = x * y * z;
12:         promedio = suma / 3;
13:         
14:         print("Números: ", x, ", ", y, ", ", z);
15:         print("Suma: ", suma);
16:         print("Producto: ", producto);
17:         print("Promedio: ", promedio);
18:     }
19: ];
20: 
21: void comparar_numeros(num1 : int, num2 : int)
22: [
23:     {
24:         print("Comparando ", num1, " y ", num2);
25:         
26:         if (num1 > num2) {
27:             print(num1, " es mayor que ", num2);
28:         } else {
29:             if (num1 < num2) {
30:                 print(num1, " es menor que ", num2);
31:             } else {
32:                 print(num1, " es igual a ", num2);
33:             };
34:         };
35:     }
36: ];
37: 
38: void serie_aritmetica(inicio : int, diferencia : int, terminos : int)
39: [
40:     var i, valor : int;
41:     {
42:         print("Serie aritmética:");
43:         print("Inicio: ", inicio, ", Diferencia: ", diferencia, ", Términos: ", terminos);
44:         
45:         i = 0;
46:         valor = inicio;
47:         while (i < terminos) do {
48:             print("Término ", i + 1, ": ", valor);
49:             valor = valor + diferencia;
50:             i = i + 1;
51:         };
52:     }
53: ];
54: 
55: main {
56:     operaciones_basicas(4, 7, 2);
57:     
58:     comparar_numeros(15, 8);
59:     comparar_numeros(5, 12);
60:     comparar_numeros(9, 9);
61:     
62:     serie_aritmetica(5, 3, 6);
63: }
64: end

SALIDA OBTENIDA:
Agregando ID 'a' a lista temporal en ámbito: global
'a' agregado a lista temporal de variables en ámbito: global
Agregando ID 'b' a lista temporal en ámbito: global
'b' agregado a lista temporal de variables en ámbito: global
Agregando ID 'c' a lista temporal en ámbito: global
'c' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'a' agregada de tipo Type.INT en dirección 5000
Variable global 'b' agregada de tipo Type.INT en dirección 5001
Variable global 'c' agregada de tipo Type.INT en dirección 5002
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.FLOAT
Agregando variables a tabla en ámbito: global
Variable global 'resultado' agregada de tipo Type.FLOAT en dirección 8000
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: operaciones_basicas, pila de ámbitos actual: ['global', 'operaciones_basicas']
Función 'operaciones_basicas' declarada con tipo de retorno Type.VOID, ámbito cambiado a: operaciones_basicas
Parámetro 'x' agregado de tipo Type.INT en dirección 11000 a función 'operaciones_basicas'
Parámetro 'y' agregado de tipo Type.INT en dirección 11001 a función 'operaciones_basicas'
Parámetro 'z' agregado de tipo Type.INT en dirección 11002 a función 'operaciones_basicas'
Agregando ID 'suma' a lista temporal en ámbito: operaciones_basicas
'suma' agregado a lista temporal de variables en ámbito: operaciones_basicas
Agregando ID 'producto' a lista temporal en ámbito: operaciones_basicas
'producto' agregado a lista temporal de variables en ámbito: operaciones_basicas
Agregando ID 'promedio' a lista temporal en ámbito: operaciones_basicas
'promedio' agregado a lista temporal de variables en ámbito: operaciones_basicas
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: operaciones_basicas
Variable local 'suma' agregada de tipo Type.INT en dirección 11003 a función 'operaciones_basicas'
Variable local 'producto' agregada de tipo Type.INT en dirección 11004 a función 'operaciones_basicas'
Variable local 'promedio' agregada de tipo Type.INT en dirección 11005 a función 'operaciones_basicas'
Iniciando declaración de variables en ámbito 'operaciones_basicas'
Ámbito removido: operaciones_basicas, ámbito actual es ahora: global
Declaración de función 'operaciones_basicas' terminada, regresado al ámbito: global
Ámbito agregado: comparar_numeros, pila de ámbitos actual: ['global', 'comparar_numeros']
Función 'comparar_numeros' declarada con tipo de retorno Type.VOID, ámbito cambiado a: comparar_numeros
Parámetro 'num1' agregado de tipo Type.INT en dirección 11006 a función 'comparar_numeros'
Parámetro 'num2' agregado de tipo Type.INT en dirección 11007 a función 'comparar_numeros'
Ámbito removido: comparar_numeros, ámbito actual es ahora: global
Declaración de función 'comparar_numeros' terminada, regresado al ámbito: global
Ámbito agregado: serie_aritmetica, pila de ámbitos actual: ['global', 'serie_aritmetica']
Función 'serie_aritmetica' declarada con tipo de retorno Type.VOID, ámbito cambiado a: serie_aritmetica
Parámetro 'inicio' agregado de tipo Type.INT en dirección 11008 a función 'serie_aritmetica'
Parámetro 'diferencia' agregado de tipo Type.INT en dirección 11009 a función 'serie_aritmetica'
Parámetro 'terminos' agregado de tipo Type.INT en dirección 11010 a función 'serie_aritmetica'
Agregando ID 'i' a lista temporal en ámbito: serie_aritmetica
'i' agregado a lista temporal de variables en ámbito: serie_aritmetica
Agregando ID 'valor' a lista temporal en ámbito: serie_aritmetica
'valor' agregado a lista temporal de variables en ámbito: serie_aritmetica
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: serie_aritmetica
Variable local 'i' agregada de tipo Type.INT en dirección 11011 a función 'serie_aritmetica'
Variable local 'valor' agregada de tipo Type.INT en dirección 11012 a función 'serie_aritmetica'
Iniciando declaración de variables en ámbito 'serie_aritmetica'
Ámbito removido: serie_aritmetica, ámbito actual es ahora: global
Declaración de función 'serie_aritmetica' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa funciones_parametros iniciado, ámbito reiniciado a global
Programa funciones_parametros completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: operaciones_basicas - Dirección de Inicio: 1
Función: comparar_numeros - Dirección de Inicio: 22
Función: serie_aritmetica - Dirección de Inicio: 42
Función: main - Dirección de Inicio: 64
----------------------------------------------------------------------
0: (goto, None, None, 64)
        saltar al cuádruplo 64
----------------------------------------------------------------------

==================== FUNCIÓN: operaciones_basicas ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (+, 11000, 11001, 15000)
        sumar dir:11000 y dir:11001, guardar resultado en dir:15000
----------------------------------------------------------------------
2: (+, 15000, 11002, 15001)
        sumar dir:15000 y dir:11002, guardar resultado en dir:15001
----------------------------------------------------------------------
3: (=, 15001, None, 11003)
        asignar valor de dir:15001 a dir:11003
----------------------------------------------------------------------
4: (*, 11000, 11001, 15002)
        multiplicar dir:11000 y dir:11001, guardar resultado en dir:15002
----------------------------------------------------------------------
5: (*, 15002, 11002, 15003)
        multiplicar dir:15002 y dir:11002, guardar resultado en dir:15003
----------------------------------------------------------------------
6: (=, 15003, None, 11004)
        asignar valor de dir:15003 a dir:11004
----------------------------------------------------------------------
7: (/, 11003, 20000, 17000)
        dividir dir:11003 y constante(3), guardar resultado en dir:17000
----------------------------------------------------------------------
8: (=, 17000, None, 11005)
        asignar valor de dir:17000 a dir:11005
----------------------------------------------------------------------
9: (print, Números: , None, None)
        imprimir valor dir:Números: 
----------------------------------------------------------------------
10: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
11: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
12: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
13: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
14: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
15: (print, Suma: , None, None)
        imprimir valor dir:Suma: 
----------------------------------------------------------------------
16: (print, 11003, None, None)
        imprimir valor dir:11003
----------------------------------------------------------------------
17: (print, Producto: , None, None)
        imprimir valor dir:Producto: 
----------------------------------------------------------------------
18: (print, 11004, None, None)
        imprimir valor dir:11004
----------------------------------------------------------------------
19: (print, Promedio: , None, None)
        imprimir valor dir:Promedio: 
----------------------------------------------------------------------
20: (print, 11005, None, None)
        imprimir valor dir:11005
----------------------------------------------------------------------
21: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE operaciones_basicas ====================
----------------------------------------------------------------------

==================== FUNCIÓN: comparar_numeros ====================
Inicia en el cuádruplo 22
----------------------------------------------------------------------
22: (print, Comparando , None, None)
        imprimir valor dir:Comparando 
----------------------------------------------------------------------
23: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
24: (print,  y , None, None)
        imprimir valor dir: y 
----------------------------------------------------------------------
25: (print, 11007, None, None)
        imprimir valor dir:11007
----------------------------------------------------------------------
26: (>, 11006, 11007, 19000)
        comparar si dir:11006 es mayor que dir:11007, guardar resultado booleano en dir:19000
----------------------------------------------------------------------
27: (gotof, 19000, None, 32)
        si dir:19000 es falso, saltar al cuádruplo 32
----------------------------------------------------------------------
28: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
29: (print,  es mayor que , None, None)
        imprimir valor dir: es mayor que 
----------------------------------------------------------------------
30: (print, 11007, None, None)
        imprimir valor dir:11007
----------------------------------------------------------------------
31: (goto, None, None, 41)
        saltar al cuádruplo 41
----------------------------------------------------------------------
32: (<, 11006, 11007, 19001)
        comparar si dir:11006 es menor que dir:11007, guardar resultado booleano en dir:19001
----------------------------------------------------------------------
33: (gotof, 19001, None, 38)
        si dir:19001 es falso, saltar al cuádruplo 38
----------------------------------------------------------------------
34: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
35: (print,  es menor que , None, None)
        imprimir valor dir: es menor que 
----------------------------------------------------------------------
36: (print, 11007, None, None)
        imprimir valor dir:11007
----------------------------------------------------------------------
37: (goto, None, None, 41)
        saltar al cuádruplo 41
----------------------------------------------------------------------
38: (print, 11006, None, None)
        imprimir valor dir:11006
----------------------------------------------------------------------
39: (print,  es igual a , None, None)
        imprimir valor dir: es igual a 
----------------------------------------------------------------------
40: (print, 11007, None, None)
        imprimir valor dir:11007
----------------------------------------------------------------------
41: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE comparar_numeros ====================
----------------------------------------------------------------------

==================== FUNCIÓN: serie_aritmetica ====================
Inicia en el cuádruplo 42
----------------------------------------------------------------------
42: (print, Serie aritmética:, None, None)
        imprimir valor dir:Serie aritmética:
----------------------------------------------------------------------
43: (print, Inicio: , None, None)
        imprimir valor dir:Inicio: 
----------------------------------------------------------------------
44: (print, 11008, None, None)
        imprimir valor dir:11008
----------------------------------------------------------------------
45: (print, , Diferencia: , None, None)
        imprimir valor dir:, Diferencia: 
----------------------------------------------------------------------
46: (print, 11009, None, None)
        imprimir valor dir:11009
----------------------------------------------------------------------
47: (print, , Términos: , None, None)
        imprimir valor dir:, Términos: 
----------------------------------------------------------------------
48: (print, 11010, None, None)
        imprimir valor dir:11010
----------------------------------------------------------------------
49: (=, 20001, None, 11011)
        asignar valor de constante(0) a dir:11011
----------------------------------------------------------------------
50: (=, 11008, None, 11012)
        asignar valor de dir:11008 a dir:11012
----------------------------------------------------------------------
51: (<, 11011, 11010, 19002)
        comparar si dir:11011 es menor que dir:11010, guardar resultado booleano en dir:19002
----------------------------------------------------------------------
52: (gotof, 19002, None, 63)
        si dir:19002 es falso, saltar al cuádruplo 63
----------------------------------------------------------------------
53: (+, 11011, 20002, 15004)
        sumar dir:11011 y constante(1), guardar resultado en dir:15004
----------------------------------------------------------------------
54: (print, Término , None, None)
        imprimir valor dir:Término 
----------------------------------------------------------------------
55: (print, 15004, None, None)
        imprimir valor dir:15004
----------------------------------------------------------------------
56: (print, : , None, None)
        imprimir valor dir:: 
----------------------------------------------------------------------
57: (print, 11012, None, None)
        imprimir valor dir:11012
----------------------------------------------------------------------
58: (+, 11012, 11009, 15005)
        sumar dir:11012 y dir:11009, guardar resultado en dir:15005
----------------------------------------------------------------------
59: (=, 15005, None, 11012)
        asignar valor de dir:15005 a dir:11012
----------------------------------------------------------------------
60: (+, 11011, 20002, 15006)
        sumar dir:11011 y constante(1), guardar resultado en dir:15006
----------------------------------------------------------------------
61: (=, 15006, None, 11011)
        asignar valor de dir:15006 a dir:11011
----------------------------------------------------------------------
62: (goto, None, None, 51)
        saltar al cuádruplo 51
----------------------------------------------------------------------
63: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE serie_aritmetica ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 64
----------------------------------------------------------------------
64: (ERA, operaciones_basicas, None, None)
        realizar operación ERA con operando dir:operaciones_basicas
----------------------------------------------------------------------
65: (parámetro, 20003, par1, None)
        realizar operación parámetro con operandos constante(4), dir:par1, resultado en None
----------------------------------------------------------------------
66: (parámetro, 20004, par2, None)
        realizar operación parámetro con operandos constante(7), dir:par2, resultado en None
----------------------------------------------------------------------
67: (parámetro, 20005, par3, None)
        realizar operación parámetro con operandos constante(2), dir:par3, resultado en None
----------------------------------------------------------------------
68: (GOSUB, operaciones_basicas, None, None)
        realizar operación GOSUB con operando dir:operaciones_basicas
----------------------------------------------------------------------
69: (ERA, comparar_numeros, None, None)
        realizar operación ERA con operando dir:comparar_numeros
----------------------------------------------------------------------
70: (parámetro, 20006, par1, None)
        realizar operación parámetro con operandos constante(15), dir:par1, resultado en None
----------------------------------------------------------------------
71: (parámetro, 20007, par2, None)
        realizar operación parámetro con operandos constante(8), dir:par2, resultado en None
----------------------------------------------------------------------
72: (GOSUB, comparar_numeros, None, None)
        realizar operación GOSUB con operando dir:comparar_numeros
----------------------------------------------------------------------
73: (ERA, comparar_numeros, None, None)
        realizar operación ERA con operando dir:comparar_numeros
----------------------------------------------------------------------
74: (parámetro, 20008, par1, None)
        realizar operación parámetro con operandos constante(5), dir:par1, resultado en None
----------------------------------------------------------------------
75: (parámetro, 20009, par2, None)
        realizar operación parámetro con operandos constante(12), dir:par2, resultado en None
----------------------------------------------------------------------
76: (GOSUB, comparar_numeros, None, None)
        realizar operación GOSUB con operando dir:comparar_numeros
----------------------------------------------------------------------
77: (ERA, comparar_numeros, None, None)
        realizar operación ERA con operando dir:comparar_numeros
----------------------------------------------------------------------
78: (parámetro, 20010, par1, None)
        realizar operación parámetro con operandos constante(9), dir:par1, resultado en None
----------------------------------------------------------------------
79: (parámetro, 20010, par2, None)
        realizar operación parámetro con operandos constante(9), dir:par2, resultado en None
----------------------------------------------------------------------
80: (GOSUB, comparar_numeros, None, None)
        realizar operación GOSUB con operando dir:comparar_numeros
----------------------------------------------------------------------
81: (ERA, serie_aritmetica, None, None)
        realizar operación ERA con operando dir:serie_aritmetica
----------------------------------------------------------------------
82: (parámetro, 20008, par1, None)
        realizar operación parámetro con operandos constante(5), dir:par1, resultado en None
----------------------------------------------------------------------
83: (parámetro, 20000, par2, None)
        realizar operación parámetro con operandos constante(3), dir:par2, resultado en None
----------------------------------------------------------------------
84: (parámetro, 20011, par3, None)
        realizar operación parámetro con operandos constante(6), dir:par3, resultado en None
----------------------------------------------------------------------
85: (GOSUB, serie_aritmetica, None, None)
        realizar operación GOSUB con operando dir:serie_aritmetica
----------------------------------------------------------------------
86: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 64)
  Salto a: 64
IP: 64 -> Ejecutando: (ERA, operaciones_basicas, None, None)
  ERA: Reservando espacio para función 'operaciones_basicas'
IP: 65 -> Ejecutando: (parámetro, 20003, par1, None)
  Parámetro: 4 -> posición 1
IP: 66 -> Ejecutando: (parámetro, 20004, par2, None)
  Parámetro: 7 -> posición 2
IP: 67 -> Ejecutando: (parámetro, 20005, par3, None)
  Parámetro: 2 -> posición 3
IP: 68 -> Ejecutando: (GOSUB, operaciones_basicas, None, None)
    Asignando parámetro x (addr: 11000) = 4
    Asignando parámetro y (addr: 11001) = 7
    Asignando parámetro z (addr: 11002) = 2
  GOSUB: Llamando función 'operaciones_basicas' en dirección 1
IP: 1 -> Ejecutando: (+, 11000, 11001, 15000)
  Aritmética: 4 + 7 = 11
IP: 2 -> Ejecutando: (+, 15000, 11002, 15001)
  Aritmética: 11 + 2 = 13
IP: 3 -> Ejecutando: (=, 15001, None, 11003)
  Asignación: direccion[11003] = 13
IP: 4 -> Ejecutando: (*, 11000, 11001, 15002)
  Aritmética: 4 * 7 = 28
IP: 5 -> Ejecutando: (*, 15002, 11002, 15003)
  Aritmética: 28 * 2 = 56
IP: 6 -> Ejecutando: (=, 15003, None, 11004)
  Asignación: direccion[11004] = 56
IP: 7 -> Ejecutando: (/, 11003, 20000, 17000)
  Aritmética: 13 / 3 = 4.333333333333333
IP: 8 -> Ejecutando: (=, 17000, None, 11005)
  Asignación: direccion[11005] = 4.333333333333333
IP: 9 -> Ejecutando: (print, Números: , None, None)
OUTPUT: Números: 
IP: 10 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 4
IP: 11 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 12 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 7
IP: 13 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 15 -> Ejecutando: (print, Suma: , None, None)
OUTPUT: Suma: 
IP: 16 -> Ejecutando: (print, 11003, None, None)
OUTPUT: 13
IP: 17 -> Ejecutando: (print, Producto: , None, None)
OUTPUT: Producto: 
IP: 18 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 56
IP: 19 -> Ejecutando: (print, Promedio: , None, None)
OUTPUT: Promedio: 
IP: 20 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 4
IP: 21 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 69
IP: 69 -> Ejecutando: (ERA, comparar_numeros, None, None)
  ERA: Reservando espacio para función 'comparar_numeros'
IP: 70 -> Ejecutando: (parámetro, 20006, par1, None)
  Parámetro: 15 -> posición 1
IP: 71 -> Ejecutando: (parámetro, 20007, par2, None)
  Parámetro: 8 -> posición 2
IP: 72 -> Ejecutando: (GOSUB, comparar_numeros, None, None)
    Asignando parámetro num1 (addr: 11006) = 15
    Asignando parámetro num2 (addr: 11007) = 8
  GOSUB: Llamando función 'comparar_numeros' en dirección 22
IP: 22 -> Ejecutando: (print, Comparando , None, None)
OUTPUT: Comparando 
IP: 23 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 15
IP: 24 -> Ejecutando: (print,  y , None, None)
OUTPUT:  y 
IP: 25 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 8
IP: 26 -> Ejecutando: (>, 11006, 11007, 19000)
  Comparación: 15 > 8 = True
IP: 27 -> Ejecutando: (gotof, 19000, None, 32)
  No hay salto (condición verdadera)
IP: 28 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 15
IP: 29 -> Ejecutando: (print,  es mayor que , None, None)
OUTPUT:  es mayor que 
IP: 30 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 8
IP: 31 -> Ejecutando: (goto, None, None, 41)
  Salto a: 41
IP: 41 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 73
IP: 73 -> Ejecutando: (ERA, comparar_numeros, None, None)
  ERA: Reservando espacio para función 'comparar_numeros'
IP: 74 -> Ejecutando: (parámetro, 20008, par1, None)
  Parámetro: 5 -> posición 1
IP: 75 -> Ejecutando: (parámetro, 20009, par2, None)
  Parámetro: 12 -> posición 2
IP: 76 -> Ejecutando: (GOSUB, comparar_numeros, None, None)
    Asignando parámetro num1 (addr: 11006) = 5
    Asignando parámetro num2 (addr: 11007) = 12
  GOSUB: Llamando función 'comparar_numeros' en dirección 22
IP: 22 -> Ejecutando: (print, Comparando , None, None)
OUTPUT: Comparando 
IP: 23 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 5
IP: 24 -> Ejecutando: (print,  y , None, None)
OUTPUT:  y 
IP: 25 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 12
IP: 26 -> Ejecutando: (>, 11006, 11007, 19000)
  Comparación: 5 > 12 = False
IP: 27 -> Ejecutando: (gotof, 19000, None, 32)
  Salto condicional a: 32 (condición falsa)
IP: 32 -> Ejecutando: (<, 11006, 11007, 19001)
  Comparación: 5 < 12 = True
IP: 33 -> Ejecutando: (gotof, 19001, None, 38)
  No hay salto (condición verdadera)
IP: 34 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 5
IP: 35 -> Ejecutando: (print,  es menor que , None, None)
OUTPUT:  es menor que 
IP: 36 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 12
IP: 37 -> Ejecutando: (goto, None, None, 41)
  Salto a: 41
IP: 41 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 77
IP: 77 -> Ejecutando: (ERA, comparar_numeros, None, None)
  ERA: Reservando espacio para función 'comparar_numeros'
IP: 78 -> Ejecutando: (parámetro, 20010, par1, None)
  Parámetro: 9 -> posición 1
IP: 79 -> Ejecutando: (parámetro, 20010, par2, None)
  Parámetro: 9 -> posición 2
IP: 80 -> Ejecutando: (GOSUB, comparar_numeros, None, None)
    Asignando parámetro num1 (addr: 11006) = 9
    Asignando parámetro num2 (addr: 11007) = 9
  GOSUB: Llamando función 'comparar_numeros' en dirección 22
IP: 22 -> Ejecutando: (print, Comparando , None, None)
OUTPUT: Comparando 
IP: 23 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 9
IP: 24 -> Ejecutando: (print,  y , None, None)
OUTPUT:  y 
IP: 25 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 9
IP: 26 -> Ejecutando: (>, 11006, 11007, 19000)
  Comparación: 9 > 9 = False
IP: 27 -> Ejecutando: (gotof, 19000, None, 32)
  Salto condicional a: 32 (condición falsa)
IP: 32 -> Ejecutando: (<, 11006, 11007, 19001)
  Comparación: 9 < 9 = False
IP: 33 -> Ejecutando: (gotof, 19001, None, 38)
  Salto condicional a: 38 (condición falsa)
IP: 38 -> Ejecutando: (print, 11006, None, None)
OUTPUT: 9
IP: 39 -> Ejecutando: (print,  es igual a , None, None)
OUTPUT:  es igual a 
IP: 40 -> Ejecutando: (print, 11007, None, None)
OUTPUT: 9
IP: 41 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 81
IP: 81 -> Ejecutando: (ERA, serie_aritmetica, None, None)
  ERA: Reservando espacio para función 'serie_aritmetica'
IP: 82 -> Ejecutando: (parámetro, 20008, par1, None)
  Parámetro: 5 -> posición 1
IP: 83 -> Ejecutando: (parámetro, 20000, par2, None)
  Parámetro: 3 -> posición 2
IP: 84 -> Ejecutando: (parámetro, 20011, par3, None)
  Parámetro: 6 -> posición 3
IP: 85 -> Ejecutando: (GOSUB, serie_aritmetica, None, None)
    Asignando parámetro inicio (addr: 11008) = 5
    Asignando parámetro diferencia (addr: 11009) = 3
    Asignando parámetro terminos (addr: 11010) = 6
  GOSUB: Llamando función 'serie_aritmetica' en dirección 42
IP: 42 -> Ejecutando: (print, Serie aritmética:, None, None)
OUTPUT: Serie aritmética:
IP: 43 -> Ejecutando: (print, Inicio: , None, None)
OUTPUT: Inicio: 
IP: 44 -> Ejecutando: (print, 11008, None, None)
OUTPUT: 5
IP: 45 -> Ejecutando: (print, , Diferencia: , None, None)
OUTPUT: , Diferencia: 
IP: 46 -> Ejecutando: (print, 11009, None, None)
OUTPUT: 3
IP: 47 -> Ejecutando: (print, , Términos: , None, None)
OUTPUT: , Términos: 
IP: 48 -> Ejecutando: (print, 11010, None, None)
OUTPUT: 6
IP: 49 -> Ejecutando: (=, 20001, None, 11011)
  Asignación: direccion[11011] = 0
IP: 50 -> Ejecutando: (=, 11008, None, 11012)
  Asignación: direccion[11012] = 5
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 0 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 0 + 1 = 1
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 1
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 5
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 5 + 3 = 8
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 8
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 0 + 1 = 1
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 1
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 1 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 1 + 1 = 2
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 2
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 8
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 8 + 3 = 11
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 11
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 1 + 1 = 2
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 2
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 2 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 2 + 1 = 3
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 3
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 11
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 11 + 3 = 14
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 14
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 2 + 1 = 3
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 3
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 3 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 3 + 1 = 4
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 4
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 14
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 14 + 3 = 17
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 17
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 3 + 1 = 4
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 4
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 4 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 4 + 1 = 5
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 5
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 17
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 17 + 3 = 20
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 20
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 4 + 1 = 5
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 5
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 5 < 6 = True
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  No hay salto (condición verdadera)
IP: 53 -> Ejecutando: (+, 11011, 20002, 15004)
  Aritmética: 5 + 1 = 6
IP: 54 -> Ejecutando: (print, Término , None, None)
OUTPUT: Término 
IP: 55 -> Ejecutando: (print, 15004, None, None)
OUTPUT: 6
IP: 56 -> Ejecutando: (print, : , None, None)
OUTPUT: : 
IP: 57 -> Ejecutando: (print, 11012, None, None)
OUTPUT: 20
IP: 58 -> Ejecutando: (+, 11012, 11009, 15005)
  Aritmética: 20 + 3 = 23
IP: 59 -> Ejecutando: (=, 15005, None, 11012)
  Asignación: direccion[11012] = 23
IP: 60 -> Ejecutando: (+, 11011, 20002, 15006)
  Aritmética: 5 + 1 = 6
IP: 61 -> Ejecutando: (=, 15006, None, 11011)
  Asignación: direccion[11011] = 6
IP: 62 -> Ejecutando: (goto, None, None, 51)
  Salto a: 51
IP: 51 -> Ejecutando: (<, 11011, 11010, 19002)
  Comparación: 6 < 6 = False
IP: 52 -> Ejecutando: (gotof, 19002, None, 63)
  Salto condicional a: 63 (condición falsa)
IP: 63 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 86
IP: 86 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 11
  [15001]: 13
  [15002]: 28
  [15003]: 56
  [15004]: 6
  [15005]: 23
  [15006]: 6
Memoria Temporal Flotantes (17000-18999):
  [17000]: 4.333333333333333
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
  [19001]: False
  [19002]: False
Constantes Enteras (20000-20499):
  [20000]: 3
  [20001]: 0
  [20002]: 1
  [20003]: 4
  [20004]: 7
  [20005]: 2
  [20006]: 15
  [20007]: 8
  [20008]: 5
  [20009]: 12
  [20010]: 9
  [20011]: 6
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - Números:
  - 4
  - ,
  - 7
  - ,
  - 2
  - Suma:
  - 13
  - Producto:
  - 56
  - Promedio:
  - 4
  - Comparando
  - 15
  - y
  - 8
  - 15
  - es mayor que
  - 8
  - Comparando
  - 5
  - y
  - 12
  - 5
  - es menor que
  - 12
  - Comparando
  - 9
  - y
  - 9
  - 9
  - es igual a
  - 9
  - Serie aritmética:
  - Inicio:
  - 5
  - Diferencia:
  - 3
  - Términos:
  - 6
  - Término
  - 1
  - :
  - 5
  - Término
  - 6
  - :
  - 20

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 11] FOR con Función
------------------------------------------------------------
CÓDIGO:
 1: program for_con_funcion;
 2: var
 3:     limite : int;
 4: 
 5: void contar_hasta(n : int)
 6: [
 7:     var i, contador : int;
 8:     {
 9:         print("Contando hasta ", n, ":");
10:         contador = 0;
11:         
12:         for (i = 1; i < n + 1; i = i + 1) do {
13:             contador = contador + 1;
14:             print("Contador: ", contador, " (i = ", i, ")");
15:         };
16:         
17:         print("Terminé de contar hasta ", n);
18:     }
19: ];
20: 
21: void tabla_cuadrados(hasta : int)
22: [
23:     var i, cuadrado : int;
24:     {
25:         print("Tabla de cuadrados hasta ", hasta, ":");
26:         
27:         for (i = 1; i < hasta + 1; i = i + 1) do {
28:             cuadrado = i * i;
29:             print(i, " al cuadrado = ", cuadrado);
30:         };
31:     }
32: ];
33: 
34: main {
35:     limite = 5;
36:     
37:     contar_hasta(limite);
38:     
39:     tabla_cuadrados(4);
40:     
41:     print("FOR anidado:");
42:     for (limite = 1; limite < 4; limite = limite + 1) do {
43:         print("Tabla del ", limite, ":");
44:         contar_hasta(limite);
45:     };
46: }
47: end

SALIDA OBTENIDA:
Agregando ID 'limite' a lista temporal en ámbito: global
'limite' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'limite' agregada de tipo Type.INT en dirección 5000
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: contar_hasta, pila de ámbitos actual: ['global', 'contar_hasta']
Función 'contar_hasta' declarada con tipo de retorno Type.VOID, ámbito cambiado a: contar_hasta
Parámetro 'n' agregado de tipo Type.INT en dirección 11000 a función 'contar_hasta'
Agregando ID 'i' a lista temporal en ámbito: contar_hasta
'i' agregado a lista temporal de variables en ámbito: contar_hasta
Agregando ID 'contador' a lista temporal en ámbito: contar_hasta
'contador' agregado a lista temporal de variables en ámbito: contar_hasta
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: contar_hasta
Variable local 'i' agregada de tipo Type.INT en dirección 11001 a función 'contar_hasta'
Variable local 'contador' agregada de tipo Type.INT en dirección 11002 a función 'contar_hasta'
Iniciando declaración de variables en ámbito 'contar_hasta'
Ámbito removido: contar_hasta, ámbito actual es ahora: global
Declaración de función 'contar_hasta' terminada, regresado al ámbito: global
Ámbito agregado: tabla_cuadrados, pila de ámbitos actual: ['global', 'tabla_cuadrados']
Función 'tabla_cuadrados' declarada con tipo de retorno Type.VOID, ámbito cambiado a: tabla_cuadrados
Parámetro 'hasta' agregado de tipo Type.INT en dirección 11003 a función 'tabla_cuadrados'
Agregando ID 'i' a lista temporal en ámbito: tabla_cuadrados
'i' agregado a lista temporal de variables en ámbito: tabla_cuadrados
Agregando ID 'cuadrado' a lista temporal en ámbito: tabla_cuadrados
'cuadrado' agregado a lista temporal de variables en ámbito: tabla_cuadrados
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: tabla_cuadrados
Variable local 'i' agregada de tipo Type.INT en dirección 11004 a función 'tabla_cuadrados'
Variable local 'cuadrado' agregada de tipo Type.INT en dirección 11005 a función 'tabla_cuadrados'
Iniciando declaración de variables en ámbito 'tabla_cuadrados'
Ámbito removido: tabla_cuadrados, ámbito actual es ahora: global
Declaración de función 'tabla_cuadrados' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa for_con_funcion iniciado, ámbito reiniciado a global
Programa for_con_funcion completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: contar_hasta - Dirección de Inicio: 1
Función: tabla_cuadrados - Dirección de Inicio: 23
Función: main - Dirección de Inicio: 40
----------------------------------------------------------------------
0: (goto, None, None, 40)
        saltar al cuádruplo 40
----------------------------------------------------------------------

==================== FUNCIÓN: contar_hasta ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (print, Contando hasta , None, None)
        imprimir valor dir:Contando hasta 
----------------------------------------------------------------------
2: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
3: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
4: (=, 20000, None, 11002)
        asignar valor de constante(0) a dir:11002
----------------------------------------------------------------------
5: (=, 20001, None, 11001)
        asignar valor de constante(1) a dir:11001
----------------------------------------------------------------------
6: (+, 11000, 20001, 15000)
        sumar dir:11000 y constante(1), guardar resultado en dir:15000
----------------------------------------------------------------------
7: (<, 11001, 15000, 19000)
        comparar si dir:11001 es menor que dir:15000, guardar resultado booleano en dir:19000
----------------------------------------------------------------------
8: (gotof, 19000, None, 20)
        si dir:19000 es falso, saltar al cuádruplo 20
----------------------------------------------------------------------
9: (+, 11001, 20001, 15001)
        sumar dir:11001 y constante(1), guardar resultado en dir:15001
----------------------------------------------------------------------
10: (=, 15001, None, 11001)
        asignar valor de dir:15001 a dir:11001
----------------------------------------------------------------------
11: (+, 11002, 20001, 15002)
        sumar dir:11002 y constante(1), guardar resultado en dir:15002
----------------------------------------------------------------------
12: (=, 15002, None, 11002)
        asignar valor de dir:15002 a dir:11002
----------------------------------------------------------------------
13: (print, Contador: , None, None)
        imprimir valor dir:Contador: 
----------------------------------------------------------------------
14: (print, 11002, None, None)
        imprimir valor dir:11002
----------------------------------------------------------------------
15: (print,  (i = , None, None)
        imprimir valor dir: (i = 
----------------------------------------------------------------------
16: (print, 11001, None, None)
        imprimir valor dir:11001
----------------------------------------------------------------------
17: (print, ), None, None)
        imprimir valor dir:)
----------------------------------------------------------------------
18: (=, 15001, None, 11001)
        asignar valor de dir:15001 a dir:11001
----------------------------------------------------------------------
19: (goto, None, None, 6)
        saltar al cuádruplo 6
----------------------------------------------------------------------
20: (print, Terminé de contar hasta , None, None)
        imprimir valor dir:Terminé de contar hasta 
----------------------------------------------------------------------
21: (print, 11000, None, None)
        imprimir valor dir:11000
----------------------------------------------------------------------
22: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE contar_hasta ====================
----------------------------------------------------------------------

==================== FUNCIÓN: tabla_cuadrados ====================
Inicia en el cuádruplo 23
----------------------------------------------------------------------
23: (print, Tabla de cuadrados hasta , None, None)
        imprimir valor dir:Tabla de cuadrados hasta 
----------------------------------------------------------------------
24: (print, 11003, None, None)
        imprimir valor dir:11003
----------------------------------------------------------------------
25: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
26: (=, 20001, None, 11004)
        asignar valor de constante(1) a dir:11004
----------------------------------------------------------------------
27: (+, 11003, 20001, 15003)
        sumar dir:11003 y constante(1), guardar resultado en dir:15003
----------------------------------------------------------------------
28: (<, 11004, 15003, 19001)
        comparar si dir:11004 es menor que dir:15003, guardar resultado booleano en dir:19001
----------------------------------------------------------------------
29: (gotof, 19001, None, 39)
        si dir:19001 es falso, saltar al cuádruplo 39
----------------------------------------------------------------------
30: (+, 11004, 20001, 15004)
        sumar dir:11004 y constante(1), guardar resultado en dir:15004
----------------------------------------------------------------------
31: (=, 15004, None, 11004)
        asignar valor de dir:15004 a dir:11004
----------------------------------------------------------------------
32: (*, 11004, 11004, 15005)
        multiplicar dir:11004 y dir:11004, guardar resultado en dir:15005
----------------------------------------------------------------------
33: (=, 15005, None, 11005)
        asignar valor de dir:15005 a dir:11005
----------------------------------------------------------------------
34: (print, 11004, None, None)
        imprimir valor dir:11004
----------------------------------------------------------------------
35: (print,  al cuadrado = , None, None)
        imprimir valor dir: al cuadrado = 
----------------------------------------------------------------------
36: (print, 11005, None, None)
        imprimir valor dir:11005
----------------------------------------------------------------------
37: (=, 15004, None, 11004)
        asignar valor de dir:15004 a dir:11004
----------------------------------------------------------------------
38: (goto, None, None, 27)
        saltar al cuádruplo 27
----------------------------------------------------------------------
39: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE tabla_cuadrados ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 40
----------------------------------------------------------------------
40: (=, 20002, None, 5000)
        asignar valor de constante(5) a limite (global)
----------------------------------------------------------------------
41: (ERA, contar_hasta, None, None)
        realizar operación ERA con operando dir:contar_hasta
----------------------------------------------------------------------
42: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos limite (global), dir:par1, resultado en None
----------------------------------------------------------------------
43: (GOSUB, contar_hasta, None, None)
        realizar operación GOSUB con operando dir:contar_hasta
----------------------------------------------------------------------
44: (ERA, tabla_cuadrados, None, None)
        realizar operación ERA con operando temp tabla_cuadrados
----------------------------------------------------------------------
45: (parámetro, 20003, par1, None)
        realizar operación parámetro con operandos constante(4), dir:par1, resultado en None
----------------------------------------------------------------------
46: (GOSUB, tabla_cuadrados, None, None)
        realizar operación GOSUB con operando temp tabla_cuadrados
----------------------------------------------------------------------
47: (print, FOR anidado:, None, None)
        imprimir valor dir:FOR anidado:
----------------------------------------------------------------------
48: (=, 20001, None, 5000)
        asignar valor de constante(1) a limite (global)
----------------------------------------------------------------------
49: (<, 5000, 20003, 19002)
        comparar si limite (global) es menor que constante(4), guardar resultado booleano en dir:19002
----------------------------------------------------------------------
50: (gotof, 19002, None, 61)
        si dir:19002 es falso, saltar al cuádruplo 61
----------------------------------------------------------------------
51: (+, 5000, 20001, 15006)
        sumar limite (global) y constante(1), guardar resultado en dir:15006
----------------------------------------------------------------------
52: (=, 15006, None, 5000)
        asignar valor de dir:15006 a limite (global)
----------------------------------------------------------------------
53: (print, Tabla del , None, None)
        imprimir valor dir:Tabla del 
----------------------------------------------------------------------
54: (print, 5000, None, None)
        imprimir valor limite (global)
----------------------------------------------------------------------
55: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
56: (ERA, contar_hasta, None, None)
        realizar operación ERA con operando dir:contar_hasta
----------------------------------------------------------------------
57: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos limite (global), dir:par1, resultado en None
----------------------------------------------------------------------
58: (GOSUB, contar_hasta, None, None)
        realizar operación GOSUB con operando dir:contar_hasta
----------------------------------------------------------------------
59: (=, 15006, None, 5000)
        asignar valor de dir:15006 a limite (global)
----------------------------------------------------------------------
60: (goto, None, None, 49)
        saltar al cuádruplo 49
----------------------------------------------------------------------
61: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (=, 20002, None, 5000)
  Asignación: direccion[5000] = 5
IP: 41 -> Ejecutando: (ERA, contar_hasta, None, None)
  ERA: Reservando espacio para función 'contar_hasta'
IP: 42 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 5 -> posición 1
IP: 43 -> Ejecutando: (GOSUB, contar_hasta, None, None)
    Asignando parámetro n (addr: 11000) = 5
  GOSUB: Llamando función 'contar_hasta' en dirección 1
IP: 1 -> Ejecutando: (print, Contando hasta , None, None)
OUTPUT: Contando hasta 
IP: 2 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 5
IP: 3 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 4 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 0
IP: 5 -> Ejecutando: (=, 20001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 1 < 6 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 1 + 1 = 2
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 0 + 1 = 1
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 1
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 2 < 6 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 2 + 1 = 3
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 1 + 1 = 2
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 3
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 3 < 6 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 3 + 1 = 4
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 2 + 1 = 3
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 4
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 4 < 6 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 4 + 1 = 5
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 5
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 3 + 1 = 4
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 4
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 4
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 5
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 5
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 5 < 6 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 5 + 1 = 6
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 6
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 4 + 1 = 5
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 5
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 5
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 6
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 6
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 5 + 1 = 6
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 6 < 6 = False
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  Salto condicional a: 20 (condición falsa)
IP: 20 -> Ejecutando: (print, Terminé de contar hasta , None, None)
OUTPUT: Terminé de contar hasta 
IP: 21 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 5
IP: 22 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 44
IP: 44 -> Ejecutando: (ERA, tabla_cuadrados, None, None)
  ERA: Reservando espacio para función 'tabla_cuadrados'
IP: 45 -> Ejecutando: (parámetro, 20003, par1, None)
  Parámetro: 4 -> posición 1
IP: 46 -> Ejecutando: (GOSUB, tabla_cuadrados, None, None)
    Asignando parámetro hasta (addr: 11003) = 4
  GOSUB: Llamando función 'tabla_cuadrados' en dirección 23
IP: 23 -> Ejecutando: (print, Tabla de cuadrados hasta , None, None)
OUTPUT: Tabla de cuadrados hasta 
IP: 24 -> Ejecutando: (print, 11003, None, None)
OUTPUT: 4
IP: 25 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 26 -> Ejecutando: (=, 20001, None, 11004)
  Asignación: direccion[11004] = 1
IP: 27 -> Ejecutando: (+, 11003, 20001, 15003)
  Aritmética: 4 + 1 = 5
IP: 28 -> Ejecutando: (<, 11004, 15003, 19001)
  Comparación: 1 < 5 = True
IP: 29 -> Ejecutando: (gotof, 19001, None, 39)
  No hay salto (condición verdadera)
IP: 30 -> Ejecutando: (+, 11004, 20001, 15004)
  Aritmética: 1 + 1 = 2
IP: 31 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 2
IP: 32 -> Ejecutando: (*, 11004, 11004, 15005)
  Aritmética: 2 * 2 = 4
IP: 33 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 4
IP: 34 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 2
IP: 35 -> Ejecutando: (print,  al cuadrado = , None, None)
OUTPUT:  al cuadrado = 
IP: 36 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 4
IP: 37 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 2
IP: 38 -> Ejecutando: (goto, None, None, 27)
  Salto a: 27
IP: 27 -> Ejecutando: (+, 11003, 20001, 15003)
  Aritmética: 4 + 1 = 5
IP: 28 -> Ejecutando: (<, 11004, 15003, 19001)
  Comparación: 2 < 5 = True
IP: 29 -> Ejecutando: (gotof, 19001, None, 39)
  No hay salto (condición verdadera)
IP: 30 -> Ejecutando: (+, 11004, 20001, 15004)
  Aritmética: 2 + 1 = 3
IP: 31 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 3
IP: 32 -> Ejecutando: (*, 11004, 11004, 15005)
  Aritmética: 3 * 3 = 9
IP: 33 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 9
IP: 34 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 3
IP: 35 -> Ejecutando: (print,  al cuadrado = , None, None)
OUTPUT:  al cuadrado = 
IP: 36 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 9
IP: 37 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 3
IP: 38 -> Ejecutando: (goto, None, None, 27)
  Salto a: 27
IP: 27 -> Ejecutando: (+, 11003, 20001, 15003)
  Aritmética: 4 + 1 = 5
IP: 28 -> Ejecutando: (<, 11004, 15003, 19001)
  Comparación: 3 < 5 = True
IP: 29 -> Ejecutando: (gotof, 19001, None, 39)
  No hay salto (condición verdadera)
IP: 30 -> Ejecutando: (+, 11004, 20001, 15004)
  Aritmética: 3 + 1 = 4
IP: 31 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 4
IP: 32 -> Ejecutando: (*, 11004, 11004, 15005)
  Aritmética: 4 * 4 = 16
IP: 33 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 16
IP: 34 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 4
IP: 35 -> Ejecutando: (print,  al cuadrado = , None, None)
OUTPUT:  al cuadrado = 
IP: 36 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 16
IP: 37 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 4
IP: 38 -> Ejecutando: (goto, None, None, 27)
  Salto a: 27
IP: 27 -> Ejecutando: (+, 11003, 20001, 15003)
  Aritmética: 4 + 1 = 5
IP: 28 -> Ejecutando: (<, 11004, 15003, 19001)
  Comparación: 4 < 5 = True
IP: 29 -> Ejecutando: (gotof, 19001, None, 39)
  No hay salto (condición verdadera)
IP: 30 -> Ejecutando: (+, 11004, 20001, 15004)
  Aritmética: 4 + 1 = 5
IP: 31 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 5
IP: 32 -> Ejecutando: (*, 11004, 11004, 15005)
  Aritmética: 5 * 5 = 25
IP: 33 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 25
IP: 34 -> Ejecutando: (print, 11004, None, None)
OUTPUT: 5
IP: 35 -> Ejecutando: (print,  al cuadrado = , None, None)
OUTPUT:  al cuadrado = 
IP: 36 -> Ejecutando: (print, 11005, None, None)
OUTPUT: 25
IP: 37 -> Ejecutando: (=, 15004, None, 11004)
  Asignación: direccion[11004] = 5
IP: 38 -> Ejecutando: (goto, None, None, 27)
  Salto a: 27
IP: 27 -> Ejecutando: (+, 11003, 20001, 15003)
  Aritmética: 4 + 1 = 5
IP: 28 -> Ejecutando: (<, 11004, 15003, 19001)
  Comparación: 5 < 5 = False
IP: 29 -> Ejecutando: (gotof, 19001, None, 39)
  Salto condicional a: 39 (condición falsa)
IP: 39 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 47
IP: 47 -> Ejecutando: (print, FOR anidado:, None, None)
OUTPUT: FOR anidado:
IP: 48 -> Ejecutando: (=, 20001, None, 5000)
  Asignación: direccion[5000] = 1
IP: 49 -> Ejecutando: (<, 5000, 20003, 19002)
  Comparación: 1 < 4 = True
IP: 50 -> Ejecutando: (gotof, 19002, None, 61)
  No hay salto (condición verdadera)
IP: 51 -> Ejecutando: (+, 5000, 20001, 15006)
  Aritmética: 1 + 1 = 2
IP: 52 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 2
IP: 53 -> Ejecutando: (print, Tabla del , None, None)
OUTPUT: Tabla del 
IP: 54 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 2
IP: 55 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 56 -> Ejecutando: (ERA, contar_hasta, None, None)
  ERA: Reservando espacio para función 'contar_hasta'
IP: 57 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 2 -> posición 1
IP: 58 -> Ejecutando: (GOSUB, contar_hasta, None, None)
    Asignando parámetro n (addr: 11000) = 2
  GOSUB: Llamando función 'contar_hasta' en dirección 1
IP: 1 -> Ejecutando: (print, Contando hasta , None, None)
OUTPUT: Contando hasta 
IP: 2 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 2
IP: 3 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 4 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 0
IP: 5 -> Ejecutando: (=, 20001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 2 + 1 = 3
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 1 < 3 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 1 + 1 = 2
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 0 + 1 = 1
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 1
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 2 + 1 = 3
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 2 < 3 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 2 + 1 = 3
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 1 + 1 = 2
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 3
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 2 + 1 = 3
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 3 < 3 = False
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  Salto condicional a: 20 (condición falsa)
IP: 20 -> Ejecutando: (print, Terminé de contar hasta , None, None)
OUTPUT: Terminé de contar hasta 
IP: 21 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 2
IP: 22 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 59
IP: 59 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 2
IP: 60 -> Ejecutando: (goto, None, None, 49)
  Salto a: 49
IP: 49 -> Ejecutando: (<, 5000, 20003, 19002)
  Comparación: 2 < 4 = True
IP: 50 -> Ejecutando: (gotof, 19002, None, 61)
  No hay salto (condición verdadera)
IP: 51 -> Ejecutando: (+, 5000, 20001, 15006)
  Aritmética: 2 + 1 = 3
IP: 52 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 3
IP: 53 -> Ejecutando: (print, Tabla del , None, None)
OUTPUT: Tabla del 
IP: 54 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 3
IP: 55 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 56 -> Ejecutando: (ERA, contar_hasta, None, None)
  ERA: Reservando espacio para función 'contar_hasta'
IP: 57 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 3 -> posición 1
IP: 58 -> Ejecutando: (GOSUB, contar_hasta, None, None)
    Asignando parámetro n (addr: 11000) = 3
  GOSUB: Llamando función 'contar_hasta' en dirección 1
IP: 1 -> Ejecutando: (print, Contando hasta , None, None)
OUTPUT: Contando hasta 
IP: 2 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 3
IP: 3 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 4 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 0
IP: 5 -> Ejecutando: (=, 20001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 3 + 1 = 4
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 1 < 4 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 1 + 1 = 2
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 0 + 1 = 1
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 1
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 3 + 1 = 4
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 2 < 4 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 2 + 1 = 3
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 1 + 1 = 2
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 3
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 3 + 1 = 4
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 3 < 4 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 3 + 1 = 4
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 2 + 1 = 3
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 4
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 3 + 1 = 4
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 4 < 4 = False
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  Salto condicional a: 20 (condición falsa)
IP: 20 -> Ejecutando: (print, Terminé de contar hasta , None, None)
OUTPUT: Terminé de contar hasta 
IP: 21 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 3
IP: 22 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 59
IP: 59 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 3
IP: 60 -> Ejecutando: (goto, None, None, 49)
  Salto a: 49
IP: 49 -> Ejecutando: (<, 5000, 20003, 19002)
  Comparación: 3 < 4 = True
IP: 50 -> Ejecutando: (gotof, 19002, None, 61)
  No hay salto (condición verdadera)
IP: 51 -> Ejecutando: (+, 5000, 20001, 15006)
  Aritmética: 3 + 1 = 4
IP: 52 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 4
IP: 53 -> Ejecutando: (print, Tabla del , None, None)
OUTPUT: Tabla del 
IP: 54 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 4
IP: 55 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 56 -> Ejecutando: (ERA, contar_hasta, None, None)
  ERA: Reservando espacio para función 'contar_hasta'
IP: 57 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 4 -> posición 1
IP: 58 -> Ejecutando: (GOSUB, contar_hasta, None, None)
    Asignando parámetro n (addr: 11000) = 4
  GOSUB: Llamando función 'contar_hasta' en dirección 1
IP: 1 -> Ejecutando: (print, Contando hasta , None, None)
OUTPUT: Contando hasta 
IP: 2 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 4
IP: 3 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 4 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 0
IP: 5 -> Ejecutando: (=, 20001, None, 11001)
  Asignación: direccion[11001] = 1
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 4 + 1 = 5
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 1 < 5 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 1 + 1 = 2
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 0 + 1 = 1
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 1
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 1
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 2
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 2
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 4 + 1 = 5
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 2 < 5 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 2 + 1 = 3
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 1 + 1 = 2
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 2
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 2
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 3
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 3
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 4 + 1 = 5
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 3 < 5 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 3 + 1 = 4
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 2 + 1 = 3
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 3
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 3
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 4
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 4
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 4 + 1 = 5
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 4 < 5 = True
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  No hay salto (condición verdadera)
IP: 9 -> Ejecutando: (+, 11001, 20001, 15001)
  Aritmética: 4 + 1 = 5
IP: 10 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 5
IP: 11 -> Ejecutando: (+, 11002, 20001, 15002)
  Aritmética: 3 + 1 = 4
IP: 12 -> Ejecutando: (=, 15002, None, 11002)
  Asignación: direccion[11002] = 4
IP: 13 -> Ejecutando: (print, Contador: , None, None)
OUTPUT: Contador: 
IP: 14 -> Ejecutando: (print, 11002, None, None)
OUTPUT: 4
IP: 15 -> Ejecutando: (print,  (i = , None, None)
OUTPUT:  (i = 
IP: 16 -> Ejecutando: (print, 11001, None, None)
OUTPUT: 5
IP: 17 -> Ejecutando: (print, ), None, None)
OUTPUT: )
IP: 18 -> Ejecutando: (=, 15001, None, 11001)
  Asignación: direccion[11001] = 5
IP: 19 -> Ejecutando: (goto, None, None, 6)
  Salto a: 6
IP: 6 -> Ejecutando: (+, 11000, 20001, 15000)
  Aritmética: 4 + 1 = 5
IP: 7 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 5 < 5 = False
IP: 8 -> Ejecutando: (gotof, 19000, None, 20)
  Salto condicional a: 20 (condición falsa)
IP: 20 -> Ejecutando: (print, Terminé de contar hasta , None, None)
OUTPUT: Terminé de contar hasta 
IP: 21 -> Ejecutando: (print, 11000, None, None)
OUTPUT: 4
IP: 22 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 59
IP: 59 -> Ejecutando: (=, 15006, None, 5000)
  Asignación: direccion[5000] = 4
IP: 60 -> Ejecutando: (goto, None, None, 49)
  Salto a: 49
IP: 49 -> Ejecutando: (<, 5000, 20003, 19002)
  Comparación: 4 < 4 = False
IP: 50 -> Ejecutando: (gotof, 19002, None, 61)
  Salto condicional a: 61 (condición falsa)
IP: 61 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 4
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 5
  [15001]: 5
  [15002]: 4
  [15003]: 5
  [15004]: 5
  [15005]: 25
  [15006]: 4
Memoria Temporal Flotantes (17000-18999):
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
  [19001]: False
  [19002]: False
Constantes Enteras (20000-20499):
  [20000]: 0
  [20001]: 1
  [20002]: 5
  [20003]: 4
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - Contando hasta
  - 5
  - Contador:
  - 1
  - (i =
  - 1
  - )
  - Contador:
  - 5
  - (i =
  - 5
  - )
  - Terminé de contar hasta
  - 5
  - Tabla de cuadrados hasta
  - 4
  - 1
  - al cuadrado =
  - 1
  - 4
  - al cuadrado =
  - 16
  - FOR anidado:
  - Tabla del
  - 1
  - Tabla del
  - 3
  - Terminé de contar hasta
  - 3

✅ PRUEBA EXITOSA
------------------------------------------------------------

[TEST 12] Calculadora Avanzada
------------------------------------------------------------
CÓDIGO:
 1: program calculadora_avanzada;
 2: var 
 3:     num1, num2, num3, resultado, factorial_num : int;
 4:     promedio_val : int;
 5:     
 6: int calcular_factorial(n : int)
 7: [
 8:     var i, fact : int;
 9:     {
10:         fact = 1;
11:         i = 1;
12:         while (i < n + 1) do {
13:             fact = fact * i;
14:             i = i + 1;
15:         };
16:         return fact;
17:     }
18: ];
19: 
20: int potencia(base : int, exponente : int)
21: [
22:     var i, resultado : int;
23:     {
24:         resultado = 1;
25:         i = 1;
26:         while (i < exponente + 1) do {
27:             resultado = resultado * base;
28:             i = i + 1;
29:         };
30:         return resultado;
31:     }
32: ];
33: 
34: int maximo_de_tres(a : int, b : int, c : int)
35: [
36:     var max : int;
37:     {
38:         max = a;
39:         if (b > max) {
40:             max = b;
41:         };
42:         if (c > max) {
43:             max = c;
44:         };
45:         return max;
46:     }
47: ];
48: 
49: void mostrar_tabla_multiplicar(numero : int, limite : int)
50: [
51:     var i, producto : int;
52:     {
53:         print("Tabla de multiplicar del ", numero, ":");
54:         i = 1;
55:         while (i < limite + 1) do {
56:             producto = numero * i;
57:             print(numero, " x ", i, " = ", producto);
58:             i = i + 1;
59:         };
60:     }
61: ];
62: 
63: void analizar_numero(num : int)
64: [
65:     {
66:         print("Analizando el número: ", num);
67:         
68:         if (num > 0) {
69:             print("El número es positivo");
70:         } else {
71:             if (num < 0) {
72:                 print("El número es negativo");
73:             } else {
74:                 print("El número es cero");
75:             };
76:         };
77:                 
78:         if (num > 0) {
79:             print("El número es par");
80:         } else {
81:             print("El número es impar");
82:         };
83:     }
84: ];
85: 
86: void mostrar_operaciones_basicas(a : int, b : int)
87: [
88:     var suma, resta, multiplicacion, division : int;
89:     {
90:         suma = a + b;
91:         resta = a - b;
92:         multiplicacion = a * b;
93:         
94:         print("Operaciones básicas entre ", a, " y ", b, ":");
95:         print("Suma: ", suma);
96:         print("Resta: ", resta);
97:         print("Multiplicación: ", multiplicacion);
98:         
99:         if (b > 0) {
100:             division = a / b;
101:             print("División: ", division);
102:         } else {
103:             print("No se puede dividir entre cero");
104:         };
105:     }
106: ];
107: 
108: int calcular_promedio(a : int, b : int, c : int)
109: [
110:     var suma, promedio : int;
111:     {
112:         suma = a + b + c;
113:         promedio = suma / 3;
114:         return promedio;
115:     }
116: ];
117: 
118: void mostrar_estadisticas(a : int, b : int, c : int)
119: [
120:     var suma, mayor, menor : int;
121:     {
122:         suma = a + b + c;
123:         mayor = maximo_de_tres(a, b, c);
124:         
125:         menor = a;
126:         if (b < menor) {
127:             menor = b;
128:         };
129:         if (c < menor) {
130:             menor = c;
131:         };
132:             
133:         print("=== ESTADÍSTICAS ===");
134:         print("Números: ", a, ", ", b, ", ", c);
135:         print("Suma total: ", suma);
136:         print("Número mayor: ", mayor);
137:         print("Número menor: ", menor);
138:         print("Promedio: ", calcular_promedio(a, b, c));
139:     }
140: ];
141: 
142: main {
143:     print("=== CALCULADORA AVANZADA ===");
144:     
145:     num1 = 12;
146:     num2 = 8;
147:     num3 = 15;
148:     
149:     print("Números de trabajo: ", num1, ", ", num2, ", ", num3);
150:     print("");
151:     
152:     mostrar_operaciones_basicas(num1, num2);
153:     print("");
154:     
155:     analizar_numero(num1);
156:     print("");
157:     
158:     mostrar_tabla_multiplicar(num2, 5);
159:     print("");
160:     
161:     factorial_num = 5;
162:     resultado = calcular_factorial(factorial_num);
163:     print("Factorial de ", factorial_num, " es: ", resultado);
164:     
165:     resultado = potencia(num2, 3);
166:     print(num2, " elevado a la 3 es: ", resultado);
167:     
168:     resultado = maximo_de_tres(num1, num2, num3);
169:     print("El mayor de los tres números es: ", resultado);
170:     
171:     promedio_val = calcular_promedio(num1, num2, num3);
172:     print("El promedio de los tres números es: ", promedio_val);
173:     print("");
174:     
175:     mostrar_estadisticas(num1, num2, num3);
176:     
177:     print("");
178:     print("=== FIN DEL PROGRAMA ===");
179: }
180: end

SALIDA OBTENIDA:
Agregando ID 'num1' a lista temporal en ámbito: global
'num1' agregado a lista temporal de variables en ámbito: global
Agregando ID 'num2' a lista temporal en ámbito: global
'num2' agregado a lista temporal de variables en ámbito: global
Agregando ID 'num3' a lista temporal en ámbito: global
'num3' agregado a lista temporal de variables en ámbito: global
Agregando ID 'resultado' a lista temporal en ámbito: global
'resultado' agregado a lista temporal de variables en ámbito: global
Agregando ID 'factorial_num' a lista temporal en ámbito: global
'factorial_num' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'num1' agregada de tipo Type.INT en dirección 5000
Variable global 'num2' agregada de tipo Type.INT en dirección 5001
Variable global 'num3' agregada de tipo Type.INT en dirección 5002
Variable global 'resultado' agregada de tipo Type.INT en dirección 5003
Variable global 'factorial_num' agregada de tipo Type.INT en dirección 5004
Agregando ID 'promedio_val' a lista temporal en ámbito: global
'promedio_val' agregado a lista temporal de variables en ámbito: global
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: global
Variable global 'promedio_val' agregada de tipo Type.INT en dirección 5005
Iniciando declaración de variables en ámbito 'global'
Ámbito agregado: calcular_factorial, pila de ámbitos actual: ['global', 'calcular_factorial']
Función 'calcular_factorial' declarada con tipo de retorno Type.INT, ámbito cambiado a: calcular_factorial
Parámetro 'n' agregado de tipo Type.INT en dirección 11000 a función 'calcular_factorial'
Agregando ID 'i' a lista temporal en ámbito: calcular_factorial
'i' agregado a lista temporal de variables en ámbito: calcular_factorial
Agregando ID 'fact' a lista temporal en ámbito: calcular_factorial
'fact' agregado a lista temporal de variables en ámbito: calcular_factorial
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: calcular_factorial
Variable local 'i' agregada de tipo Type.INT en dirección 11001 a función 'calcular_factorial'
Variable local 'fact' agregada de tipo Type.INT en dirección 11002 a función 'calcular_factorial'
Iniciando declaración de variables en ámbito 'calcular_factorial'
Ámbito removido: calcular_factorial, ámbito actual es ahora: global
Declaración de función 'calcular_factorial' terminada, regresado al ámbito: global
Ámbito agregado: potencia, pila de ámbitos actual: ['global', 'potencia']
Función 'potencia' declarada con tipo de retorno Type.INT, ámbito cambiado a: potencia
Parámetro 'base' agregado de tipo Type.INT en dirección 11003 a función 'potencia'
Parámetro 'exponente' agregado de tipo Type.INT en dirección 11004 a función 'potencia'
Agregando ID 'i' a lista temporal en ámbito: potencia
'i' agregado a lista temporal de variables en ámbito: potencia
Agregando ID 'resultado' a lista temporal en ámbito: potencia
'resultado' agregado a lista temporal de variables en ámbito: potencia
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: potencia
Variable local 'i' agregada de tipo Type.INT en dirección 11005 a función 'potencia'
Variable local 'resultado' agregada de tipo Type.INT en dirección 11006 a función 'potencia'
Iniciando declaración de variables en ámbito 'potencia'
Ámbito removido: potencia, ámbito actual es ahora: global
Declaración de función 'potencia' terminada, regresado al ámbito: global
Ámbito agregado: maximo_de_tres, pila de ámbitos actual: ['global', 'maximo_de_tres']
Función 'maximo_de_tres' declarada con tipo de retorno Type.INT, ámbito cambiado a: maximo_de_tres
Parámetro 'a' agregado de tipo Type.INT en dirección 11007 a función 'maximo_de_tres'
Parámetro 'b' agregado de tipo Type.INT en dirección 11008 a función 'maximo_de_tres'
Parámetro 'c' agregado de tipo Type.INT en dirección 11009 a función 'maximo_de_tres'
Agregando ID 'max' a lista temporal en ámbito: maximo_de_tres
'max' agregado a lista temporal de variables en ámbito: maximo_de_tres
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: maximo_de_tres
Variable local 'max' agregada de tipo Type.INT en dirección 11010 a función 'maximo_de_tres'
Iniciando declaración de variables en ámbito 'maximo_de_tres'
Ámbito removido: maximo_de_tres, ámbito actual es ahora: global
Declaración de función 'maximo_de_tres' terminada, regresado al ámbito: global
Ámbito agregado: mostrar_tabla_multiplicar, pila de ámbitos actual: ['global', 'mostrar_tabla_multiplicar']
Función 'mostrar_tabla_multiplicar' declarada con tipo de retorno Type.VOID, ámbito cambiado a: mostrar_tabla_multiplicar
Parámetro 'numero' agregado de tipo Type.INT en dirección 11011 a función 'mostrar_tabla_multiplicar'
Parámetro 'limite' agregado de tipo Type.INT en dirección 11012 a función 'mostrar_tabla_multiplicar'
Agregando ID 'i' a lista temporal en ámbito: mostrar_tabla_multiplicar
'i' agregado a lista temporal de variables en ámbito: mostrar_tabla_multiplicar
Agregando ID 'producto' a lista temporal en ámbito: mostrar_tabla_multiplicar
'producto' agregado a lista temporal de variables en ámbito: mostrar_tabla_multiplicar
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: mostrar_tabla_multiplicar
Variable local 'i' agregada de tipo Type.INT en dirección 11013 a función 'mostrar_tabla_multiplicar'
Variable local 'producto' agregada de tipo Type.INT en dirección 11014 a función 'mostrar_tabla_multiplicar'
Iniciando declaración de variables en ámbito 'mostrar_tabla_multiplicar'
Ámbito removido: mostrar_tabla_multiplicar, ámbito actual es ahora: global
Declaración de función 'mostrar_tabla_multiplicar' terminada, regresado al ámbito: global
Ámbito agregado: analizar_numero, pila de ámbitos actual: ['global', 'analizar_numero']
Función 'analizar_numero' declarada con tipo de retorno Type.VOID, ámbito cambiado a: analizar_numero
Parámetro 'num' agregado de tipo Type.INT en dirección 11015 a función 'analizar_numero'
Ámbito removido: analizar_numero, ámbito actual es ahora: global
Declaración de función 'analizar_numero' terminada, regresado al ámbito: global
Ámbito agregado: mostrar_operaciones_basicas, pila de ámbitos actual: ['global', 'mostrar_operaciones_basicas']
Función 'mostrar_operaciones_basicas' declarada con tipo de retorno Type.VOID, ámbito cambiado a: mostrar_operaciones_basicas
Parámetro 'a' agregado de tipo Type.INT en dirección 11016 a función 'mostrar_operaciones_basicas'
Parámetro 'b' agregado de tipo Type.INT en dirección 11017 a función 'mostrar_operaciones_basicas'
Agregando ID 'suma' a lista temporal en ámbito: mostrar_operaciones_basicas
'suma' agregado a lista temporal de variables en ámbito: mostrar_operaciones_basicas
Agregando ID 'resta' a lista temporal en ámbito: mostrar_operaciones_basicas
'resta' agregado a lista temporal de variables en ámbito: mostrar_operaciones_basicas
Agregando ID 'multiplicacion' a lista temporal en ámbito: mostrar_operaciones_basicas
'multiplicacion' agregado a lista temporal de variables en ámbito: mostrar_operaciones_basicas
Agregando ID 'division' a lista temporal en ámbito: mostrar_operaciones_basicas
'division' agregado a lista temporal de variables en ámbito: mostrar_operaciones_basicas
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: mostrar_operaciones_basicas
Variable local 'suma' agregada de tipo Type.INT en dirección 11018 a función 'mostrar_operaciones_basicas'
Variable local 'resta' agregada de tipo Type.INT en dirección 11019 a función 'mostrar_operaciones_basicas'
Variable local 'multiplicacion' agregada de tipo Type.INT en dirección 11020 a función 'mostrar_operaciones_basicas'
Variable local 'division' agregada de tipo Type.INT en dirección 11021 a función 'mostrar_operaciones_basicas'
Iniciando declaración de variables en ámbito 'mostrar_operaciones_basicas'
Ámbito removido: mostrar_operaciones_basicas, ámbito actual es ahora: global
Declaración de función 'mostrar_operaciones_basicas' terminada, regresado al ámbito: global
Ámbito agregado: calcular_promedio, pila de ámbitos actual: ['global', 'calcular_promedio']
Función 'calcular_promedio' declarada con tipo de retorno Type.INT, ámbito cambiado a: calcular_promedio
Parámetro 'a' agregado de tipo Type.INT en dirección 11022 a función 'calcular_promedio'
Parámetro 'b' agregado de tipo Type.INT en dirección 11023 a función 'calcular_promedio'
Parámetro 'c' agregado de tipo Type.INT en dirección 11024 a función 'calcular_promedio'
Agregando ID 'suma' a lista temporal en ámbito: calcular_promedio
'suma' agregado a lista temporal de variables en ámbito: calcular_promedio
Agregando ID 'promedio' a lista temporal en ámbito: calcular_promedio
'promedio' agregado a lista temporal de variables en ámbito: calcular_promedio
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: calcular_promedio
Variable local 'suma' agregada de tipo Type.INT en dirección 11025 a función 'calcular_promedio'
Variable local 'promedio' agregada de tipo Type.INT en dirección 11026 a función 'calcular_promedio'
Iniciando declaración de variables en ámbito 'calcular_promedio'
Ámbito removido: calcular_promedio, ámbito actual es ahora: global
Declaración de función 'calcular_promedio' terminada, regresado al ámbito: global
Ámbito agregado: mostrar_estadisticas, pila de ámbitos actual: ['global', 'mostrar_estadisticas']
Función 'mostrar_estadisticas' declarada con tipo de retorno Type.VOID, ámbito cambiado a: mostrar_estadisticas
Parámetro 'a' agregado de tipo Type.INT en dirección 11027 a función 'mostrar_estadisticas'
Parámetro 'b' agregado de tipo Type.INT en dirección 11028 a función 'mostrar_estadisticas'
Parámetro 'c' agregado de tipo Type.INT en dirección 11029 a función 'mostrar_estadisticas'
Agregando ID 'suma' a lista temporal en ámbito: mostrar_estadisticas
'suma' agregado a lista temporal de variables en ámbito: mostrar_estadisticas
Agregando ID 'mayor' a lista temporal en ámbito: mostrar_estadisticas
'mayor' agregado a lista temporal de variables en ámbito: mostrar_estadisticas
Agregando ID 'menor' a lista temporal en ámbito: mostrar_estadisticas
'menor' agregado a lista temporal de variables en ámbito: mostrar_estadisticas
Tipo actual establecido a Type.INT
Agregando variables a tabla en ámbito: mostrar_estadisticas
Variable local 'suma' agregada de tipo Type.INT en dirección 11030 a función 'mostrar_estadisticas'
Variable local 'mayor' agregada de tipo Type.INT en dirección 11031 a función 'mostrar_estadisticas'
Variable local 'menor' agregada de tipo Type.INT en dirección 11032 a función 'mostrar_estadisticas'
Iniciando declaración de variables en ámbito 'mostrar_estadisticas'
Ámbito removido: mostrar_estadisticas, ámbito actual es ahora: global
Declaración de función 'mostrar_estadisticas' terminada, regresado al ámbito: global
Ámbito agregado: main, pila de ámbitos actual: ['global', 'main']
Función main declarada, ámbito cambiado a main
Programa calculadora_avanzada iniciado, ámbito reiniciado a global
Programa calculadora_avanzada completado

===== CUÁDRUPLOS CON DIRECCIONES DE MEMORIA =====
ÍNDICE: (OPERADOR, OPERANDO_IZQ, OPERANDO_DER, RESULTADO)
        EXPLICACIÓN
----------------------------------------------------------------------

===== DIRECTORIO DE FUNCIONES =====
Función: calcular_factorial - Dirección de Inicio: 1
Función: potencia - Dirección de Inicio: 13
Función: maximo_de_tres - Dirección de Inicio: 25
Función: mostrar_tabla_multiplicar - Dirección de Inicio: 36
Función: analizar_numero - Dirección de Inicio: 54
Función: mostrar_operaciones_basicas - Dirección de Inicio: 71
Función: calcular_promedio - Dirección de Inicio: 97
Función: mostrar_estadisticas - Dirección de Inicio: 104
Función: main - Dirección de Inicio: 143
----------------------------------------------------------------------
0: (goto, None, None, 143)
        saltar al cuádruplo 143
----------------------------------------------------------------------

==================== FUNCIÓN: calcular_factorial ====================
Inicia en el cuádruplo 1
----------------------------------------------------------------------
1: (=, 20000, None, 11002)
        asignar valor de constante(1) a dir:11002
----------------------------------------------------------------------
2: (=, 20000, None, 11001)
        asignar valor de constante(1) a dir:11001
----------------------------------------------------------------------
3: (+, 11000, 20000, 15000)
        sumar dir:11000 y constante(1), guardar resultado en dir:15000
----------------------------------------------------------------------
4: (<, 11001, 15000, 19000)
        comparar si dir:11001 es menor que dir:15000, guardar resultado booleano en dir:19000
----------------------------------------------------------------------
5: (gotof, 19000, None, 11)
        si dir:19000 es falso, saltar al cuádruplo 11
----------------------------------------------------------------------
6: (*, 11002, 11001, 15001)
        multiplicar dir:11002 y dir:11001, guardar resultado en dir:15001
----------------------------------------------------------------------
7: (=, 15001, None, 11002)
        asignar valor de dir:15001 a dir:11002
----------------------------------------------------------------------
8: (+, 11001, 20000, 15002)
        sumar dir:11001 y constante(1), guardar resultado en dir:15002
----------------------------------------------------------------------
9: (=, 15002, None, 11001)
        asignar valor de dir:15002 a dir:11001
----------------------------------------------------------------------
10: (goto, None, None, 3)
        saltar al cuádruplo 3
----------------------------------------------------------------------
11: (RETURN, 11002, None, None)
        realizar operación RETURN con operando dir:11002
----------------------------------------------------------------------
12: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE calcular_factorial ====================
----------------------------------------------------------------------

==================== FUNCIÓN: potencia ====================
Inicia en el cuádruplo 13
----------------------------------------------------------------------
13: (=, 20000, None, 11006)
        asignar valor de constante(1) a dir:11006
----------------------------------------------------------------------
14: (=, 20000, None, 11005)
        asignar valor de constante(1) a dir:11005
----------------------------------------------------------------------
15: (+, 11004, 20000, 15003)
        sumar dir:11004 y constante(1), guardar resultado en dir:15003
----------------------------------------------------------------------
16: (<, 11005, 15003, 19001)
        comparar si dir:11005 es menor que dir:15003, guardar resultado booleano en dir:19001
----------------------------------------------------------------------
17: (gotof, 19001, None, 23)
        si dir:19001 es falso, saltar al cuádruplo 23
----------------------------------------------------------------------
18: (*, 11006, 11003, 15004)
        multiplicar dir:11006 y dir:11003, guardar resultado en dir:15004
----------------------------------------------------------------------
19: (=, 15004, None, 11006)
        asignar valor de dir:15004 a dir:11006
----------------------------------------------------------------------
20: (+, 11005, 20000, 15005)
        sumar dir:11005 y constante(1), guardar resultado en dir:15005
----------------------------------------------------------------------
21: (=, 15005, None, 11005)
        asignar valor de dir:15005 a dir:11005
----------------------------------------------------------------------
22: (goto, None, None, 15)
        saltar al cuádruplo 15
----------------------------------------------------------------------
23: (RETURN, 11006, None, None)
        realizar operación RETURN con operando dir:11006
----------------------------------------------------------------------
24: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE potencia ====================
----------------------------------------------------------------------

==================== FUNCIÓN: maximo_de_tres ====================
Inicia en el cuádruplo 25
----------------------------------------------------------------------
25: (=, 11007, None, 11010)
        asignar valor de dir:11007 a dir:11010
----------------------------------------------------------------------
26: (>, 11008, 11010, 19002)
        comparar si dir:11008 es mayor que dir:11010, guardar resultado booleano en dir:19002
----------------------------------------------------------------------
27: (gotof, 19002, None, 30)
        si dir:19002 es falso, saltar al cuádruplo 30
----------------------------------------------------------------------
28: (=, 11008, None, 11010)
        asignar valor de dir:11008 a dir:11010
----------------------------------------------------------------------
29: (goto, None, None, 30)
        saltar al cuádruplo 30
----------------------------------------------------------------------
30: (>, 11009, 11010, 19003)
        comparar si dir:11009 es mayor que dir:11010, guardar resultado booleano en dir:19003
----------------------------------------------------------------------
31: (gotof, 19003, None, 34)
        si dir:19003 es falso, saltar al cuádruplo 34
----------------------------------------------------------------------
32: (=, 11009, None, 11010)
        asignar valor de dir:11009 a dir:11010
----------------------------------------------------------------------
33: (goto, None, None, 34)
        saltar al cuádruplo 34
----------------------------------------------------------------------
34: (RETURN, 11010, None, None)
        realizar operación RETURN con operando dir:11010
----------------------------------------------------------------------
35: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE maximo_de_tres ====================
----------------------------------------------------------------------

==================== FUNCIÓN: mostrar_tabla_multiplicar ====================
Inicia en el cuádruplo 36
----------------------------------------------------------------------
36: (print, Tabla de multiplicar del , None, None)
        imprimir valor dir:Tabla de multiplicar del 
----------------------------------------------------------------------
37: (print, 11011, None, None)
        imprimir valor dir:11011
----------------------------------------------------------------------
38: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
39: (=, 20000, None, 11013)
        asignar valor de constante(1) a dir:11013
----------------------------------------------------------------------
40: (+, 11012, 20000, 15006)
        sumar dir:11012 y constante(1), guardar resultado en dir:15006
----------------------------------------------------------------------
41: (<, 11013, 15006, 19004)
        comparar si dir:11013 es menor que dir:15006, guardar resultado booleano en dir:19004
----------------------------------------------------------------------
42: (gotof, 19004, None, 53)
        si dir:19004 es falso, saltar al cuádruplo 53
----------------------------------------------------------------------
43: (*, 11011, 11013, 15007)
        multiplicar dir:11011 y dir:11013, guardar resultado en dir:15007
----------------------------------------------------------------------
44: (=, 15007, None, 11014)
        asignar valor de dir:15007 a dir:11014
----------------------------------------------------------------------
45: (print, 11011, None, None)
        imprimir valor dir:11011
----------------------------------------------------------------------
46: (print,  x , None, None)
        imprimir valor dir: x 
----------------------------------------------------------------------
47: (print, 11013, None, None)
        imprimir valor dir:11013
----------------------------------------------------------------------
48: (print,  = , None, None)
        imprimir valor dir: = 
----------------------------------------------------------------------
49: (print, 11014, None, None)
        imprimir valor dir:11014
----------------------------------------------------------------------
50: (+, 11013, 20000, 15008)
        sumar dir:11013 y constante(1), guardar resultado en dir:15008
----------------------------------------------------------------------
51: (=, 15008, None, 11013)
        asignar valor de dir:15008 a dir:11013
----------------------------------------------------------------------
52: (goto, None, None, 40)
        saltar al cuádruplo 40
----------------------------------------------------------------------
53: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE mostrar_tabla_multiplicar ====================
----------------------------------------------------------------------

==================== FUNCIÓN: analizar_numero ====================
Inicia en el cuádruplo 54
----------------------------------------------------------------------
54: (print, Analizando el número: , None, None)
        imprimir valor dir:Analizando el número: 
----------------------------------------------------------------------
55: (print, 11015, None, None)
        imprimir valor dir:11015
----------------------------------------------------------------------
56: (>, 11015, 20001, 19005)
        comparar si dir:11015 es mayor que constante(0), guardar resultado booleano en dir:19005
----------------------------------------------------------------------
57: (gotof, 19005, None, 60)
        si dir:19005 es falso, saltar al cuádruplo 60
----------------------------------------------------------------------
58: (print, El número es positivo, None, None)
        imprimir valor dir:El número es positivo
----------------------------------------------------------------------
59: (goto, None, None, 65)
        saltar al cuádruplo 65
----------------------------------------------------------------------
60: (<, 11015, 20001, 19006)
        comparar si dir:11015 es menor que constante(0), guardar resultado booleano en dir:19006
----------------------------------------------------------------------
61: (gotof, 19006, None, 64)
        si dir:19006 es falso, saltar al cuádruplo 64
----------------------------------------------------------------------
62: (print, El número es negativo, None, None)
        imprimir valor dir:El número es negativo
----------------------------------------------------------------------
63: (goto, None, None, 65)
        saltar al cuádruplo 65
----------------------------------------------------------------------
64: (print, El número es cero, None, None)
        imprimir valor dir:El número es cero
----------------------------------------------------------------------
65: (>, 11015, 20001, 19007)
        comparar si dir:11015 es mayor que constante(0), guardar resultado booleano en dir:19007
----------------------------------------------------------------------
66: (gotof, 19007, None, 69)
        si dir:19007 es falso, saltar al cuádruplo 69
----------------------------------------------------------------------
67: (print, El número es par, None, None)
        imprimir valor dir:El número es par
----------------------------------------------------------------------
68: (goto, None, None, 70)
        saltar al cuádruplo 70
----------------------------------------------------------------------
69: (print, El número es impar, None, None)
        imprimir valor dir:El número es impar
----------------------------------------------------------------------
70: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE analizar_numero ====================
----------------------------------------------------------------------

==================== FUNCIÓN: mostrar_operaciones_basicas ====================
Inicia en el cuádruplo 71
----------------------------------------------------------------------
71: (+, 11016, 11017, 15009)
        sumar dir:11016 y dir:11017, guardar resultado en dir:15009
----------------------------------------------------------------------
72: (=, 15009, None, 11018)
        asignar valor de dir:15009 a dir:11018
----------------------------------------------------------------------
73: (-, 11016, 11017, 15010)
        restar dir:11016 y dir:11017, guardar resultado en dir:15010
----------------------------------------------------------------------
74: (=, 15010, None, 11019)
        asignar valor de dir:15010 a dir:11019
----------------------------------------------------------------------
75: (*, 11016, 11017, 15011)
        multiplicar dir:11016 y dir:11017, guardar resultado en dir:15011
----------------------------------------------------------------------
76: (=, 15011, None, 11020)
        asignar valor de dir:15011 a dir:11020
----------------------------------------------------------------------
77: (print, Operaciones básicas entre , None, None)
        imprimir valor dir:Operaciones básicas entre 
----------------------------------------------------------------------
78: (print, 11016, None, None)
        imprimir valor dir:11016
----------------------------------------------------------------------
79: (print,  y , None, None)
        imprimir valor dir: y 
----------------------------------------------------------------------
80: (print, 11017, None, None)
        imprimir valor dir:11017
----------------------------------------------------------------------
81: (print, :, None, None)
        imprimir valor dir::
----------------------------------------------------------------------
82: (print, Suma: , None, None)
        imprimir valor dir:Suma: 
----------------------------------------------------------------------
83: (print, 11018, None, None)
        imprimir valor dir:11018
----------------------------------------------------------------------
84: (print, Resta: , None, None)
        imprimir valor dir:Resta: 
----------------------------------------------------------------------
85: (print, 11019, None, None)
        imprimir valor dir:11019
----------------------------------------------------------------------
86: (print, Multiplicación: , None, None)
        imprimir valor dir:Multiplicación: 
----------------------------------------------------------------------
87: (print, 11020, None, None)
        imprimir valor dir:11020
----------------------------------------------------------------------
88: (>, 11017, 20001, 19008)
        comparar si dir:11017 es mayor que constante(0), guardar resultado booleano en dir:19008
----------------------------------------------------------------------
89: (gotof, 19008, None, 95)
        si dir:19008 es falso, saltar al cuádruplo 95
----------------------------------------------------------------------
90: (/, 11016, 11017, 17000)
        dividir dir:11016 y dir:11017, guardar resultado en dir:17000
----------------------------------------------------------------------
91: (=, 17000, None, 11021)
        asignar valor de dir:17000 a dir:11021
----------------------------------------------------------------------
92: (print, División: , None, None)
        imprimir valor dir:División: 
----------------------------------------------------------------------
93: (print, 11021, None, None)
        imprimir valor dir:11021
----------------------------------------------------------------------
94: (goto, None, None, 96)
        saltar al cuádruplo 96
----------------------------------------------------------------------
95: (print, No se puede dividir entre cero, None, None)
        imprimir valor dir:No se puede dividir entre cero
----------------------------------------------------------------------
96: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE mostrar_operaciones_basicas ====================
----------------------------------------------------------------------

==================== FUNCIÓN: calcular_promedio ====================
Inicia en el cuádruplo 97
----------------------------------------------------------------------
97: (+, 11022, 11023, 15012)
        sumar dir:11022 y dir:11023, guardar resultado en dir:15012
----------------------------------------------------------------------
98: (+, 15012, 11024, 15013)
        sumar dir:15012 y dir:11024, guardar resultado en dir:15013
----------------------------------------------------------------------
99: (=, 15013, None, 11025)
        asignar valor de dir:15013 a dir:11025
----------------------------------------------------------------------
100: (/, 11025, 20002, 17001)
        dividir dir:11025 y constante(3), guardar resultado en dir:17001
----------------------------------------------------------------------
101: (=, 17001, None, 11026)
        asignar valor de dir:17001 a dir:11026
----------------------------------------------------------------------
102: (RETURN, 11026, None, None)
        realizar operación RETURN con operando dir:11026
----------------------------------------------------------------------
103: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE calcular_promedio ====================
----------------------------------------------------------------------

==================== FUNCIÓN: mostrar_estadisticas ====================
Inicia en el cuádruplo 104
----------------------------------------------------------------------
104: (+, 11027, 11028, 15014)
        sumar dir:11027 y dir:11028, guardar resultado en dir:15014
----------------------------------------------------------------------
105: (+, 15014, 11029, 15015)
        sumar dir:15014 y dir:11029, guardar resultado en dir:15015
----------------------------------------------------------------------
106: (=, 15015, None, 11030)
        asignar valor de dir:15015 a dir:11030
----------------------------------------------------------------------
107: (ERA, maximo_de_tres, None, None)
        realizar operación ERA con operando dir:maximo_de_tres
----------------------------------------------------------------------
108: (parámetro, 11027, par1, None)
        realizar operación parámetro con operandos dir:11027, dir:par1, resultado en None
----------------------------------------------------------------------
109: (parámetro, 11028, par2, None)
        realizar operación parámetro con operandos dir:11028, dir:par2, resultado en None
----------------------------------------------------------------------
110: (parámetro, 11029, par3, None)
        realizar operación parámetro con operandos dir:11029, dir:par3, resultado en None
----------------------------------------------------------------------
111: (GOSUB, maximo_de_tres, None, None)
        realizar operación GOSUB con operando dir:maximo_de_tres
----------------------------------------------------------------------
112: (=, 15016, None, 11031)
        asignar valor de dir:15016 a dir:11031
----------------------------------------------------------------------
113: (=, 11027, None, 11032)
        asignar valor de dir:11027 a dir:11032
----------------------------------------------------------------------
114: (<, 11028, 11032, 19009)
        comparar si dir:11028 es menor que dir:11032, guardar resultado booleano en dir:19009
----------------------------------------------------------------------
115: (gotof, 19009, None, 118)
        si dir:19009 es falso, saltar al cuádruplo 118
----------------------------------------------------------------------
116: (=, 11028, None, 11032)
        asignar valor de dir:11028 a dir:11032
----------------------------------------------------------------------
117: (goto, None, None, 118)
        saltar al cuádruplo 118
----------------------------------------------------------------------
118: (<, 11029, 11032, 19010)
        comparar si dir:11029 es menor que dir:11032, guardar resultado booleano en dir:19010
----------------------------------------------------------------------
119: (gotof, 19010, None, 122)
        si dir:19010 es falso, saltar al cuádruplo 122
----------------------------------------------------------------------
120: (=, 11029, None, 11032)
        asignar valor de dir:11029 a dir:11032
----------------------------------------------------------------------
121: (goto, None, None, 122)
        saltar al cuádruplo 122
----------------------------------------------------------------------
122: (print, === ESTADÍSTICAS ===, None, None)
        imprimir valor dir:=== ESTADÍSTICAS ===
----------------------------------------------------------------------
123: (print, Números: , None, None)
        imprimir valor dir:Números: 
----------------------------------------------------------------------
124: (print, 11027, None, None)
        imprimir valor dir:11027
----------------------------------------------------------------------
125: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
126: (print, 11028, None, None)
        imprimir valor dir:11028
----------------------------------------------------------------------
127: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
128: (print, 11029, None, None)
        imprimir valor dir:11029
----------------------------------------------------------------------
129: (print, Suma total: , None, None)
        imprimir valor dir:Suma total: 
----------------------------------------------------------------------
130: (print, 11030, None, None)
        imprimir valor dir:11030
----------------------------------------------------------------------
131: (print, Número mayor: , None, None)
        imprimir valor dir:Número mayor: 
----------------------------------------------------------------------
132: (print, 11031, None, None)
        imprimir valor dir:11031
----------------------------------------------------------------------
133: (print, Número menor: , None, None)
        imprimir valor dir:Número menor: 
----------------------------------------------------------------------
134: (print, 11032, None, None)
        imprimir valor dir:11032
----------------------------------------------------------------------
135: (ERA, calcular_promedio, None, None)
        realizar operación ERA con operando dir:calcular_promedio
----------------------------------------------------------------------
136: (parámetro, 11027, par1, None)
        realizar operación parámetro con operandos dir:11027, dir:par1, resultado en None
----------------------------------------------------------------------
137: (parámetro, 11028, par2, None)
        realizar operación parámetro con operandos dir:11028, dir:par2, resultado en None
----------------------------------------------------------------------
138: (parámetro, 11029, par3, None)
        realizar operación parámetro con operandos dir:11029, dir:par3, resultado en None
----------------------------------------------------------------------
139: (GOSUB, calcular_promedio, None, None)
        realizar operación GOSUB con operando dir:calcular_promedio
----------------------------------------------------------------------
140: (print, Promedio: , None, None)
        imprimir valor dir:Promedio: 
----------------------------------------------------------------------
141: (print, 15017, None, None)
        imprimir valor dir:15017
----------------------------------------------------------------------
142: (ENDFUNC, None, None, None)
        realizar operación ENDFUNC con operando None
==================== FIN DE mostrar_estadisticas ====================
----------------------------------------------------------------------

==================== FUNCIÓN: main ====================
Inicia en el cuádruplo 143
----------------------------------------------------------------------
143: (print, === CALCULADORA AVANZADA ===, None, None)
        imprimir valor dir:=== CALCULADORA AVANZADA ===
----------------------------------------------------------------------
144: (=, 20003, None, 5000)
        asignar valor de constante(12) a num1 (global)
----------------------------------------------------------------------
145: (=, 20004, None, 5001)
        asignar valor de constante(8) a num2 (global)
----------------------------------------------------------------------
146: (=, 20005, None, 5002)
        asignar valor de constante(15) a num3 (global)
----------------------------------------------------------------------
147: (print, Números de trabajo: , None, None)
        imprimir valor dir:Números de trabajo: 
----------------------------------------------------------------------
148: (print, 5000, None, None)
        imprimir valor num1 (global)
----------------------------------------------------------------------
149: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
150: (print, 5001, None, None)
        imprimir valor num2 (global)
----------------------------------------------------------------------
151: (print, , , None, None)
        imprimir valor dir:, 
----------------------------------------------------------------------
152: (print, 5002, None, None)
        imprimir valor num3 (global)
----------------------------------------------------------------------
153: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
154: (ERA, mostrar_operaciones_basicas, None, None)
        realizar operación ERA con operando dir:mostrar_operaciones_basicas
----------------------------------------------------------------------
155: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
156: (parámetro, 5001, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
157: (GOSUB, mostrar_operaciones_basicas, None, None)
        realizar operación GOSUB con operando dir:mostrar_operaciones_basicas
----------------------------------------------------------------------
158: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
159: (ERA, analizar_numero, None, None)
        realizar operación ERA con operando dir:analizar_numero
----------------------------------------------------------------------
160: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
161: (GOSUB, analizar_numero, None, None)
        realizar operación GOSUB con operando dir:analizar_numero
----------------------------------------------------------------------
162: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
163: (ERA, mostrar_tabla_multiplicar, None, None)
        realizar operación ERA con operando dir:mostrar_tabla_multiplicar
----------------------------------------------------------------------
164: (parámetro, 5001, par1, None)
        realizar operación parámetro con operandos num2 (global), dir:par1, resultado en None
----------------------------------------------------------------------
165: (parámetro, 20006, par2, None)
        realizar operación parámetro con operandos constante(5), dir:par2, resultado en None
----------------------------------------------------------------------
166: (GOSUB, mostrar_tabla_multiplicar, None, None)
        realizar operación GOSUB con operando dir:mostrar_tabla_multiplicar
----------------------------------------------------------------------
167: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
168: (=, 20006, None, 5004)
        asignar valor de constante(5) a factorial_num (global)
----------------------------------------------------------------------
169: (ERA, calcular_factorial, None, None)
        realizar operación ERA con operando dir:calcular_factorial
----------------------------------------------------------------------
170: (parámetro, 5004, par1, None)
        realizar operación parámetro con operandos factorial_num (global), dir:par1, resultado en None
----------------------------------------------------------------------
171: (GOSUB, calcular_factorial, None, None)
        realizar operación GOSUB con operando dir:calcular_factorial
----------------------------------------------------------------------
172: (=, 15018, None, 5003)
        asignar valor de dir:15018 a resultado (global)
----------------------------------------------------------------------
173: (print, Factorial de , None, None)
        imprimir valor dir:Factorial de 
----------------------------------------------------------------------
174: (print, 5004, None, None)
        imprimir valor factorial_num (global)
----------------------------------------------------------------------
175: (print,  es: , None, None)
        imprimir valor dir: es: 
----------------------------------------------------------------------
176: (print, 5003, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
177: (ERA, potencia, None, None)
        realizar operación ERA con operando dir:potencia
----------------------------------------------------------------------
178: (parámetro, 5001, par1, None)
        realizar operación parámetro con operandos num2 (global), dir:par1, resultado en None
----------------------------------------------------------------------
179: (parámetro, 20002, par2, None)
        realizar operación parámetro con operandos constante(3), dir:par2, resultado en None
----------------------------------------------------------------------
180: (GOSUB, potencia, None, None)
        realizar operación GOSUB con operando dir:potencia
----------------------------------------------------------------------
181: (=, 15019, None, 5003)
        asignar valor de dir:15019 a resultado (global)
----------------------------------------------------------------------
182: (print, 5001, None, None)
        imprimir valor num2 (global)
----------------------------------------------------------------------
183: (print,  elevado a la 3 es: , None, None)
        imprimir valor dir: elevado a la 3 es: 
----------------------------------------------------------------------
184: (print, 5003, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
185: (ERA, maximo_de_tres, None, None)
        realizar operación ERA con operando dir:maximo_de_tres
----------------------------------------------------------------------
186: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
187: (parámetro, 5001, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
188: (parámetro, 5002, par3, None)
        realizar operación parámetro con operandos num3 (global), dir:par3, resultado en None
----------------------------------------------------------------------
189: (GOSUB, maximo_de_tres, None, None)
        realizar operación GOSUB con operando dir:maximo_de_tres
----------------------------------------------------------------------
190: (=, 15020, None, 5003)
        asignar valor de dir:15020 a resultado (global)
----------------------------------------------------------------------
191: (print, El mayor de los tres números es: , None, None)
        imprimir valor dir:El mayor de los tres números es: 
----------------------------------------------------------------------
192: (print, 5003, None, None)
        imprimir valor resultado (global)
----------------------------------------------------------------------
193: (ERA, calcular_promedio, None, None)
        realizar operación ERA con operando dir:calcular_promedio
----------------------------------------------------------------------
194: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
195: (parámetro, 5001, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
196: (parámetro, 5002, par3, None)
        realizar operación parámetro con operandos num3 (global), dir:par3, resultado en None
----------------------------------------------------------------------
197: (GOSUB, calcular_promedio, None, None)
        realizar operación GOSUB con operando dir:calcular_promedio
----------------------------------------------------------------------
198: (=, 15021, None, 5005)
        asignar valor de dir:15021 a promedio_val (global)
----------------------------------------------------------------------
199: (print, El promedio de los tres números es: , None, None)
        imprimir valor dir:El promedio de los tres números es: 
----------------------------------------------------------------------
200: (print, 5005, None, None)
        imprimir valor promedio_val (global)
----------------------------------------------------------------------
201: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
202: (ERA, mostrar_estadisticas, None, None)
        realizar operación ERA con operando dir:mostrar_estadisticas
----------------------------------------------------------------------
203: (parámetro, 5000, par1, None)
        realizar operación parámetro con operandos num1 (global), dir:par1, resultado en None
----------------------------------------------------------------------
204: (parámetro, 5001, par2, None)
        realizar operación parámetro con operandos num2 (global), dir:par2, resultado en None
----------------------------------------------------------------------
205: (parámetro, 5002, par3, None)
        realizar operación parámetro con operandos num3 (global), dir:par3, resultado en None
----------------------------------------------------------------------
206: (GOSUB, mostrar_estadisticas, None, None)
        realizar operación GOSUB con operando dir:mostrar_estadisticas
----------------------------------------------------------------------
207: (print, , None, None)
        imprimir valor dir:
----------------------------------------------------------------------
208: (print, === FIN DEL PROGRAMA ===, None, None)
        imprimir valor dir:=== FIN DEL PROGRAMA ===
----------------------------------------------------------------------
209: (END, None, None, None)
        realizar operación END con operando None
----------------------------------------------------------------------
=== INICIANDO EJECUCIÓN ===
IP: 0 -> Ejecutando: (goto, None, None, 143)
  Salto a: 143
IP: 143 -> Ejecutando: (print, === CALCULADORA AVANZADA ===, None, None)
OUTPUT: === CALCULADORA AVANZADA ===
IP: 144 -> Ejecutando: (=, 20003, None, 5000)
  Asignación: direccion[5000] = 12
IP: 145 -> Ejecutando: (=, 20004, None, 5001)
  Asignación: direccion[5001] = 8
IP: 146 -> Ejecutando: (=, 20005, None, 5002)
  Asignación: direccion[5002] = 15
IP: 147 -> Ejecutando: (print, Números de trabajo: , None, None)
OUTPUT: Números de trabajo: 
IP: 148 -> Ejecutando: (print, 5000, None, None)
OUTPUT: 12
IP: 149 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 150 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 8
IP: 151 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 152 -> Ejecutando: (print, 5002, None, None)
OUTPUT: 15
IP: 153 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 154 -> Ejecutando: (ERA, mostrar_operaciones_basicas, None, None)
  ERA: Reservando espacio para función 'mostrar_operaciones_basicas'
IP: 155 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 12 -> posición 1
IP: 156 -> Ejecutando: (parámetro, 5001, par2, None)
  Parámetro: 8 -> posición 2
IP: 157 -> Ejecutando: (GOSUB, mostrar_operaciones_basicas, None, None)
    Asignando parámetro a (addr: 11016) = 12
    Asignando parámetro b (addr: 11017) = 8
  GOSUB: Llamando función 'mostrar_operaciones_basicas' en dirección 71
IP: 71 -> Ejecutando: (+, 11016, 11017, 15009)
  Aritmética: 12 + 8 = 20
IP: 72 -> Ejecutando: (=, 15009, None, 11018)
  Asignación: direccion[11018] = 20
IP: 73 -> Ejecutando: (-, 11016, 11017, 15010)
  Aritmética: 12 - 8 = 4
IP: 74 -> Ejecutando: (=, 15010, None, 11019)
  Asignación: direccion[11019] = 4
IP: 75 -> Ejecutando: (*, 11016, 11017, 15011)
  Aritmética: 12 * 8 = 96
IP: 76 -> Ejecutando: (=, 15011, None, 11020)
  Asignación: direccion[11020] = 96
IP: 77 -> Ejecutando: (print, Operaciones básicas entre , None, None)
OUTPUT: Operaciones básicas entre 
IP: 78 -> Ejecutando: (print, 11016, None, None)
OUTPUT: 12
IP: 79 -> Ejecutando: (print,  y , None, None)
OUTPUT:  y 
IP: 80 -> Ejecutando: (print, 11017, None, None)
OUTPUT: 8
IP: 81 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 82 -> Ejecutando: (print, Suma: , None, None)
OUTPUT: Suma: 
IP: 83 -> Ejecutando: (print, 11018, None, None)
OUTPUT: 20
IP: 84 -> Ejecutando: (print, Resta: , None, None)
OUTPUT: Resta: 
IP: 85 -> Ejecutando: (print, 11019, None, None)
OUTPUT: 4
IP: 86 -> Ejecutando: (print, Multiplicación: , None, None)
OUTPUT: Multiplicación: 
IP: 87 -> Ejecutando: (print, 11020, None, None)
OUTPUT: 96
IP: 88 -> Ejecutando: (>, 11017, 20001, 19008)
  Comparación: 8 > 0 = True
IP: 89 -> Ejecutando: (gotof, 19008, None, 95)
  No hay salto (condición verdadera)
IP: 90 -> Ejecutando: (/, 11016, 11017, 17000)
  Aritmética: 12 / 8 = 1.5
IP: 91 -> Ejecutando: (=, 17000, None, 11021)
  Asignación: direccion[11021] = 1.5
IP: 92 -> Ejecutando: (print, División: , None, None)
OUTPUT: División: 
IP: 93 -> Ejecutando: (print, 11021, None, None)
OUTPUT: 1
IP: 94 -> Ejecutando: (goto, None, None, 96)
  Salto a: 96
IP: 96 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 158
IP: 158 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 159 -> Ejecutando: (ERA, analizar_numero, None, None)
  ERA: Reservando espacio para función 'analizar_numero'
IP: 160 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 12 -> posición 1
IP: 161 -> Ejecutando: (GOSUB, analizar_numero, None, None)
    Asignando parámetro num (addr: 11015) = 12
  GOSUB: Llamando función 'analizar_numero' en dirección 54
IP: 54 -> Ejecutando: (print, Analizando el número: , None, None)
OUTPUT: Analizando el número: 
IP: 55 -> Ejecutando: (print, 11015, None, None)
OUTPUT: 12
IP: 56 -> Ejecutando: (>, 11015, 20001, 19005)
  Comparación: 12 > 0 = True
IP: 57 -> Ejecutando: (gotof, 19005, None, 60)
  No hay salto (condición verdadera)
IP: 58 -> Ejecutando: (print, El número es positivo, None, None)
OUTPUT: El número es positivo
IP: 59 -> Ejecutando: (goto, None, None, 65)
  Salto a: 65
IP: 65 -> Ejecutando: (>, 11015, 20001, 19007)
  Comparación: 12 > 0 = True
IP: 66 -> Ejecutando: (gotof, 19007, None, 69)
  No hay salto (condición verdadera)
IP: 67 -> Ejecutando: (print, El número es par, None, None)
OUTPUT: El número es par
IP: 68 -> Ejecutando: (goto, None, None, 70)
  Salto a: 70
IP: 70 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 162
IP: 162 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 163 -> Ejecutando: (ERA, mostrar_tabla_multiplicar, None, None)
  ERA: Reservando espacio para función 'mostrar_tabla_multiplicar'
IP: 164 -> Ejecutando: (parámetro, 5001, par1, None)
  Parámetro: 8 -> posición 1
IP: 165 -> Ejecutando: (parámetro, 20006, par2, None)
  Parámetro: 5 -> posición 2
IP: 166 -> Ejecutando: (GOSUB, mostrar_tabla_multiplicar, None, None)
    Asignando parámetro numero (addr: 11011) = 8
    Asignando parámetro limite (addr: 11012) = 5
  GOSUB: Llamando función 'mostrar_tabla_multiplicar' en dirección 36
IP: 36 -> Ejecutando: (print, Tabla de multiplicar del , None, None)
OUTPUT: Tabla de multiplicar del 
IP: 37 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 38 -> Ejecutando: (print, :, None, None)
OUTPUT: :
IP: 39 -> Ejecutando: (=, 20000, None, 11013)
  Asignación: direccion[11013] = 1
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 1 < 6 = True
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  No hay salto (condición verdadera)
IP: 43 -> Ejecutando: (*, 11011, 11013, 15007)
  Aritmética: 8 * 1 = 8
IP: 44 -> Ejecutando: (=, 15007, None, 11014)
  Asignación: direccion[11014] = 8
IP: 45 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 46 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 47 -> Ejecutando: (print, 11013, None, None)
OUTPUT: 1
IP: 48 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 49 -> Ejecutando: (print, 11014, None, None)
OUTPUT: 8
IP: 50 -> Ejecutando: (+, 11013, 20000, 15008)
  Aritmética: 1 + 1 = 2
IP: 51 -> Ejecutando: (=, 15008, None, 11013)
  Asignación: direccion[11013] = 2
IP: 52 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 2 < 6 = True
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  No hay salto (condición verdadera)
IP: 43 -> Ejecutando: (*, 11011, 11013, 15007)
  Aritmética: 8 * 2 = 16
IP: 44 -> Ejecutando: (=, 15007, None, 11014)
  Asignación: direccion[11014] = 16
IP: 45 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 46 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 47 -> Ejecutando: (print, 11013, None, None)
OUTPUT: 2
IP: 48 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 49 -> Ejecutando: (print, 11014, None, None)
OUTPUT: 16
IP: 50 -> Ejecutando: (+, 11013, 20000, 15008)
  Aritmética: 2 + 1 = 3
IP: 51 -> Ejecutando: (=, 15008, None, 11013)
  Asignación: direccion[11013] = 3
IP: 52 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 3 < 6 = True
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  No hay salto (condición verdadera)
IP: 43 -> Ejecutando: (*, 11011, 11013, 15007)
  Aritmética: 8 * 3 = 24
IP: 44 -> Ejecutando: (=, 15007, None, 11014)
  Asignación: direccion[11014] = 24
IP: 45 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 46 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 47 -> Ejecutando: (print, 11013, None, None)
OUTPUT: 3
IP: 48 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 49 -> Ejecutando: (print, 11014, None, None)
OUTPUT: 24
IP: 50 -> Ejecutando: (+, 11013, 20000, 15008)
  Aritmética: 3 + 1 = 4
IP: 51 -> Ejecutando: (=, 15008, None, 11013)
  Asignación: direccion[11013] = 4
IP: 52 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 4 < 6 = True
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  No hay salto (condición verdadera)
IP: 43 -> Ejecutando: (*, 11011, 11013, 15007)
  Aritmética: 8 * 4 = 32
IP: 44 -> Ejecutando: (=, 15007, None, 11014)
  Asignación: direccion[11014] = 32
IP: 45 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 46 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 47 -> Ejecutando: (print, 11013, None, None)
OUTPUT: 4
IP: 48 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 49 -> Ejecutando: (print, 11014, None, None)
OUTPUT: 32
IP: 50 -> Ejecutando: (+, 11013, 20000, 15008)
  Aritmética: 4 + 1 = 5
IP: 51 -> Ejecutando: (=, 15008, None, 11013)
  Asignación: direccion[11013] = 5
IP: 52 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 5 < 6 = True
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  No hay salto (condición verdadera)
IP: 43 -> Ejecutando: (*, 11011, 11013, 15007)
  Aritmética: 8 * 5 = 40
IP: 44 -> Ejecutando: (=, 15007, None, 11014)
  Asignación: direccion[11014] = 40
IP: 45 -> Ejecutando: (print, 11011, None, None)
OUTPUT: 8
IP: 46 -> Ejecutando: (print,  x , None, None)
OUTPUT:  x 
IP: 47 -> Ejecutando: (print, 11013, None, None)
OUTPUT: 5
IP: 48 -> Ejecutando: (print,  = , None, None)
OUTPUT:  = 
IP: 49 -> Ejecutando: (print, 11014, None, None)
OUTPUT: 40
IP: 50 -> Ejecutando: (+, 11013, 20000, 15008)
  Aritmética: 5 + 1 = 6
IP: 51 -> Ejecutando: (=, 15008, None, 11013)
  Asignación: direccion[11013] = 6
IP: 52 -> Ejecutando: (goto, None, None, 40)
  Salto a: 40
IP: 40 -> Ejecutando: (+, 11012, 20000, 15006)
  Aritmética: 5 + 1 = 6
IP: 41 -> Ejecutando: (<, 11013, 15006, 19004)
  Comparación: 6 < 6 = False
IP: 42 -> Ejecutando: (gotof, 19004, None, 53)
  Salto condicional a: 53 (condición falsa)
IP: 53 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 167
IP: 167 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 168 -> Ejecutando: (=, 20006, None, 5004)
  Asignación: direccion[5004] = 5
IP: 169 -> Ejecutando: (ERA, calcular_factorial, None, None)
  ERA: Reservando espacio para función 'calcular_factorial'
IP: 170 -> Ejecutando: (parámetro, 5004, par1, None)
  Parámetro: 5 -> posición 1
IP: 171 -> Ejecutando: (GOSUB, calcular_factorial, None, None)
    Asignando parámetro n (addr: 11000) = 5
  GOSUB: Llamando función 'calcular_factorial' en dirección 1
IP: 1 -> Ejecutando: (=, 20000, None, 11002)
  Asignación: direccion[11002] = 1
IP: 2 -> Ejecutando: (=, 20000, None, 11001)
  Asignación: direccion[11001] = 1
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 1 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11001, 15001)
  Aritmética: 1 * 1 = 1
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 1
IP: 8 -> Ejecutando: (+, 11001, 20000, 15002)
  Aritmética: 1 + 1 = 2
IP: 9 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 2
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 2 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11001, 15001)
  Aritmética: 1 * 2 = 2
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 2
IP: 8 -> Ejecutando: (+, 11001, 20000, 15002)
  Aritmética: 2 + 1 = 3
IP: 9 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 3
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 3 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11001, 15001)
  Aritmética: 2 * 3 = 6
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 6
IP: 8 -> Ejecutando: (+, 11001, 20000, 15002)
  Aritmética: 3 + 1 = 4
IP: 9 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 4
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 4 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11001, 15001)
  Aritmética: 6 * 4 = 24
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 24
IP: 8 -> Ejecutando: (+, 11001, 20000, 15002)
  Aritmética: 4 + 1 = 5
IP: 9 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 5
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 5 < 6 = True
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  No hay salto (condición verdadera)
IP: 6 -> Ejecutando: (*, 11002, 11001, 15001)
  Aritmética: 24 * 5 = 120
IP: 7 -> Ejecutando: (=, 15001, None, 11002)
  Asignación: direccion[11002] = 120
IP: 8 -> Ejecutando: (+, 11001, 20000, 15002)
  Aritmética: 5 + 1 = 6
IP: 9 -> Ejecutando: (=, 15002, None, 11001)
  Asignación: direccion[11001] = 6
IP: 10 -> Ejecutando: (goto, None, None, 3)
  Salto a: 3
IP: 3 -> Ejecutando: (+, 11000, 20000, 15000)
  Aritmética: 5 + 1 = 6
IP: 4 -> Ejecutando: (<, 11001, 15000, 19000)
  Comparación: 6 < 6 = False
IP: 5 -> Ejecutando: (gotof, 19000, None, 11)
  Salto condicional a: 11 (condición falsa)
IP: 11 -> Ejecutando: (RETURN, 11002, None, None)
  RETURN: Retornando valor 120
  ENDFUNC: Retornando a dirección 172
IP: 172 -> Ejecutando: (=, 15018, None, 5003)
  Asignación: direccion[5003] = 0
IP: 173 -> Ejecutando: (print, Factorial de , None, None)
OUTPUT: Factorial de 
IP: 174 -> Ejecutando: (print, 5004, None, None)
OUTPUT: 5
IP: 175 -> Ejecutando: (print,  es: , None, None)
OUTPUT:  es: 
IP: 176 -> Ejecutando: (print, 5003, None, None)
OUTPUT: 0
IP: 177 -> Ejecutando: (ERA, potencia, None, None)
  ERA: Reservando espacio para función 'potencia'
IP: 178 -> Ejecutando: (parámetro, 5001, par1, None)
  Parámetro: 8 -> posición 1
IP: 179 -> Ejecutando: (parámetro, 20002, par2, None)
  Parámetro: 3 -> posición 2
IP: 180 -> Ejecutando: (GOSUB, potencia, None, None)
    Asignando parámetro base (addr: 11003) = 8
    Asignando parámetro exponente (addr: 11004) = 3
  GOSUB: Llamando función 'potencia' en dirección 13
IP: 13 -> Ejecutando: (=, 20000, None, 11006)
  Asignación: direccion[11006] = 1
IP: 14 -> Ejecutando: (=, 20000, None, 11005)
  Asignación: direccion[11005] = 1
IP: 15 -> Ejecutando: (+, 11004, 20000, 15003)
  Aritmética: 3 + 1 = 4
IP: 16 -> Ejecutando: (<, 11005, 15003, 19001)
  Comparación: 1 < 4 = True
IP: 17 -> Ejecutando: (gotof, 19001, None, 23)
  No hay salto (condición verdadera)
IP: 18 -> Ejecutando: (*, 11006, 11003, 15004)
  Aritmética: 1 * 8 = 8
IP: 19 -> Ejecutando: (=, 15004, None, 11006)
  Asignación: direccion[11006] = 8
IP: 20 -> Ejecutando: (+, 11005, 20000, 15005)
  Aritmética: 1 + 1 = 2
IP: 21 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 2
IP: 22 -> Ejecutando: (goto, None, None, 15)
  Salto a: 15
IP: 15 -> Ejecutando: (+, 11004, 20000, 15003)
  Aritmética: 3 + 1 = 4
IP: 16 -> Ejecutando: (<, 11005, 15003, 19001)
  Comparación: 2 < 4 = True
IP: 17 -> Ejecutando: (gotof, 19001, None, 23)
  No hay salto (condición verdadera)
IP: 18 -> Ejecutando: (*, 11006, 11003, 15004)
  Aritmética: 8 * 8 = 64
IP: 19 -> Ejecutando: (=, 15004, None, 11006)
  Asignación: direccion[11006] = 64
IP: 20 -> Ejecutando: (+, 11005, 20000, 15005)
  Aritmética: 2 + 1 = 3
IP: 21 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 3
IP: 22 -> Ejecutando: (goto, None, None, 15)
  Salto a: 15
IP: 15 -> Ejecutando: (+, 11004, 20000, 15003)
  Aritmética: 3 + 1 = 4
IP: 16 -> Ejecutando: (<, 11005, 15003, 19001)
  Comparación: 3 < 4 = True
IP: 17 -> Ejecutando: (gotof, 19001, None, 23)
  No hay salto (condición verdadera)
IP: 18 -> Ejecutando: (*, 11006, 11003, 15004)
  Aritmética: 64 * 8 = 512
IP: 19 -> Ejecutando: (=, 15004, None, 11006)
  Asignación: direccion[11006] = 512
IP: 20 -> Ejecutando: (+, 11005, 20000, 15005)
  Aritmética: 3 + 1 = 4
IP: 21 -> Ejecutando: (=, 15005, None, 11005)
  Asignación: direccion[11005] = 4
IP: 22 -> Ejecutando: (goto, None, None, 15)
  Salto a: 15
IP: 15 -> Ejecutando: (+, 11004, 20000, 15003)
  Aritmética: 3 + 1 = 4
IP: 16 -> Ejecutando: (<, 11005, 15003, 19001)
  Comparación: 4 < 4 = False
IP: 17 -> Ejecutando: (gotof, 19001, None, 23)
  Salto condicional a: 23 (condición falsa)
IP: 23 -> Ejecutando: (RETURN, 11006, None, None)
  RETURN: Retornando valor 512
  ENDFUNC: Retornando a dirección 181
IP: 181 -> Ejecutando: (=, 15019, None, 5003)
  Asignación: direccion[5003] = 0
IP: 182 -> Ejecutando: (print, 5001, None, None)
OUTPUT: 8
IP: 183 -> Ejecutando: (print,  elevado a la 3 es: , None, None)
OUTPUT:  elevado a la 3 es: 
IP: 184 -> Ejecutando: (print, 5003, None, None)
OUTPUT: 0
IP: 185 -> Ejecutando: (ERA, maximo_de_tres, None, None)
  ERA: Reservando espacio para función 'maximo_de_tres'
IP: 186 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 12 -> posición 1
IP: 187 -> Ejecutando: (parámetro, 5001, par2, None)
  Parámetro: 8 -> posición 2
IP: 188 -> Ejecutando: (parámetro, 5002, par3, None)
  Parámetro: 15 -> posición 3
IP: 189 -> Ejecutando: (GOSUB, maximo_de_tres, None, None)
    Asignando parámetro a (addr: 11007) = 12
    Asignando parámetro b (addr: 11008) = 8
    Asignando parámetro c (addr: 11009) = 15
  GOSUB: Llamando función 'maximo_de_tres' en dirección 25
IP: 25 -> Ejecutando: (=, 11007, None, 11010)
  Asignación: direccion[11010] = 12
IP: 26 -> Ejecutando: (>, 11008, 11010, 19002)
  Comparación: 8 > 12 = False
IP: 27 -> Ejecutando: (gotof, 19002, None, 30)
  Salto condicional a: 30 (condición falsa)
IP: 30 -> Ejecutando: (>, 11009, 11010, 19003)
  Comparación: 15 > 12 = True
IP: 31 -> Ejecutando: (gotof, 19003, None, 34)
  No hay salto (condición verdadera)
IP: 32 -> Ejecutando: (=, 11009, None, 11010)
  Asignación: direccion[11010] = 15
IP: 33 -> Ejecutando: (goto, None, None, 34)
  Salto a: 34
IP: 34 -> Ejecutando: (RETURN, 11010, None, None)
  RETURN: Retornando valor 15
  ENDFUNC: Retornando a dirección 190
IP: 190 -> Ejecutando: (=, 15020, None, 5003)
  Asignación: direccion[5003] = 0
IP: 191 -> Ejecutando: (print, El mayor de los tres números es: , None, None)
OUTPUT: El mayor de los tres números es: 
IP: 192 -> Ejecutando: (print, 5003, None, None)
OUTPUT: 0
IP: 193 -> Ejecutando: (ERA, calcular_promedio, None, None)
  ERA: Reservando espacio para función 'calcular_promedio'
IP: 194 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 12 -> posición 1
IP: 195 -> Ejecutando: (parámetro, 5001, par2, None)
  Parámetro: 8 -> posición 2
IP: 196 -> Ejecutando: (parámetro, 5002, par3, None)
  Parámetro: 15 -> posición 3
IP: 197 -> Ejecutando: (GOSUB, calcular_promedio, None, None)
    Asignando parámetro a (addr: 11022) = 12
    Asignando parámetro b (addr: 11023) = 8
    Asignando parámetro c (addr: 11024) = 15
  GOSUB: Llamando función 'calcular_promedio' en dirección 97
IP: 97 -> Ejecutando: (+, 11022, 11023, 15012)
  Aritmética: 12 + 8 = 20
IP: 98 -> Ejecutando: (+, 15012, 11024, 15013)
  Aritmética: 20 + 15 = 35
IP: 99 -> Ejecutando: (=, 15013, None, 11025)
  Asignación: direccion[11025] = 35
IP: 100 -> Ejecutando: (/, 11025, 20002, 17001)
  Aritmética: 35 / 3 = 11.666666666666666
IP: 101 -> Ejecutando: (=, 17001, None, 11026)
  Asignación: direccion[11026] = 11.666666666666666
IP: 102 -> Ejecutando: (RETURN, 11026, None, None)
  RETURN: Retornando valor 11
  ENDFUNC: Retornando a dirección 198
IP: 198 -> Ejecutando: (=, 15021, None, 5005)
  Asignación: direccion[5005] = 0
IP: 199 -> Ejecutando: (print, El promedio de los tres números es: , None, None)
OUTPUT: El promedio de los tres números es: 
IP: 200 -> Ejecutando: (print, 5005, None, None)
OUTPUT: 0
IP: 201 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 202 -> Ejecutando: (ERA, mostrar_estadisticas, None, None)
  ERA: Reservando espacio para función 'mostrar_estadisticas'
IP: 203 -> Ejecutando: (parámetro, 5000, par1, None)
  Parámetro: 12 -> posición 1
IP: 204 -> Ejecutando: (parámetro, 5001, par2, None)
  Parámetro: 8 -> posición 2
IP: 205 -> Ejecutando: (parámetro, 5002, par3, None)
  Parámetro: 15 -> posición 3
IP: 206 -> Ejecutando: (GOSUB, mostrar_estadisticas, None, None)
    Asignando parámetro a (addr: 11027) = 12
    Asignando parámetro b (addr: 11028) = 8
    Asignando parámetro c (addr: 11029) = 15
  GOSUB: Llamando función 'mostrar_estadisticas' en dirección 104
IP: 104 -> Ejecutando: (+, 11027, 11028, 15014)
  Aritmética: 12 + 8 = 20
IP: 105 -> Ejecutando: (+, 15014, 11029, 15015)
  Aritmética: 20 + 15 = 35
IP: 106 -> Ejecutando: (=, 15015, None, 11030)
  Asignación: direccion[11030] = 35
IP: 107 -> Ejecutando: (ERA, maximo_de_tres, None, None)
  ERA: Reservando espacio para función 'maximo_de_tres'
IP: 108 -> Ejecutando: (parámetro, 11027, par1, None)
  Parámetro: 0 -> posición 1
IP: 109 -> Ejecutando: (parámetro, 11028, par2, None)
  Parámetro: 0 -> posición 2
IP: 110 -> Ejecutando: (parámetro, 11029, par3, None)
  Parámetro: 0 -> posición 3
IP: 111 -> Ejecutando: (GOSUB, maximo_de_tres, None, None)
    Asignando parámetro a (addr: 11007) = 0
    Asignando parámetro b (addr: 11008) = 0
    Asignando parámetro c (addr: 11009) = 0
  GOSUB: Llamando función 'maximo_de_tres' en dirección 25
IP: 25 -> Ejecutando: (=, 11007, None, 11010)
  Asignación: direccion[11010] = 0
IP: 26 -> Ejecutando: (>, 11008, 11010, 19002)
  Comparación: 0 > 0 = False
IP: 27 -> Ejecutando: (gotof, 19002, None, 30)
  Salto condicional a: 30 (condición falsa)
IP: 30 -> Ejecutando: (>, 11009, 11010, 19003)
  Comparación: 0 > 0 = False
IP: 31 -> Ejecutando: (gotof, 19003, None, 34)
  Salto condicional a: 34 (condición falsa)
IP: 34 -> Ejecutando: (RETURN, 11010, None, None)
  RETURN: Retornando valor 0
  ENDFUNC: Retornando a dirección 112
IP: 112 -> Ejecutando: (=, 15016, None, 11031)
  Asignación: direccion[11031] = 0
IP: 113 -> Ejecutando: (=, 11027, None, 11032)
  Asignación: direccion[11032] = 12
IP: 114 -> Ejecutando: (<, 11028, 11032, 19009)
  Comparación: 8 < 12 = True
IP: 115 -> Ejecutando: (gotof, 19009, None, 118)
  No hay salto (condición verdadera)
IP: 116 -> Ejecutando: (=, 11028, None, 11032)
  Asignación: direccion[11032] = 8
IP: 117 -> Ejecutando: (goto, None, None, 118)
  Salto a: 118
IP: 118 -> Ejecutando: (<, 11029, 11032, 19010)
  Comparación: 15 < 8 = False
IP: 119 -> Ejecutando: (gotof, 19010, None, 122)
  Salto condicional a: 122 (condición falsa)
IP: 122 -> Ejecutando: (print, === ESTADÍSTICAS ===, None, None)
OUTPUT: === ESTADÍSTICAS ===
IP: 123 -> Ejecutando: (print, Números: , None, None)
OUTPUT: Números: 
IP: 124 -> Ejecutando: (print, 11027, None, None)
OUTPUT: 12
IP: 125 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 126 -> Ejecutando: (print, 11028, None, None)
OUTPUT: 8
IP: 127 -> Ejecutando: (print, , , None, None)
OUTPUT: , 
IP: 128 -> Ejecutando: (print, 11029, None, None)
OUTPUT: 15
IP: 129 -> Ejecutando: (print, Suma total: , None, None)
OUTPUT: Suma total: 
IP: 130 -> Ejecutando: (print, 11030, None, None)
OUTPUT: 35
IP: 131 -> Ejecutando: (print, Número mayor: , None, None)
OUTPUT: Número mayor: 
IP: 132 -> Ejecutando: (print, 11031, None, None)
OUTPUT: 0
IP: 133 -> Ejecutando: (print, Número menor: , None, None)
OUTPUT: Número menor: 
IP: 134 -> Ejecutando: (print, 11032, None, None)
OUTPUT: 8
IP: 135 -> Ejecutando: (ERA, calcular_promedio, None, None)
  ERA: Reservando espacio para función 'calcular_promedio'
IP: 136 -> Ejecutando: (parámetro, 11027, par1, None)
  Parámetro: 0 -> posición 1
IP: 137 -> Ejecutando: (parámetro, 11028, par2, None)
  Parámetro: 0 -> posición 2
IP: 138 -> Ejecutando: (parámetro, 11029, par3, None)
  Parámetro: 0 -> posición 3
IP: 139 -> Ejecutando: (GOSUB, calcular_promedio, None, None)
    Asignando parámetro a (addr: 11022) = 0
    Asignando parámetro b (addr: 11023) = 0
    Asignando parámetro c (addr: 11024) = 0
  GOSUB: Llamando función 'calcular_promedio' en dirección 97
IP: 97 -> Ejecutando: (+, 11022, 11023, 15012)
  Aritmética: 0 + 0 = 0
IP: 98 -> Ejecutando: (+, 15012, 11024, 15013)
  Aritmética: 0 + 0 = 0
IP: 99 -> Ejecutando: (=, 15013, None, 11025)
  Asignación: direccion[11025] = 0
IP: 100 -> Ejecutando: (/, 11025, 20002, 17001)
  Aritmética: 0 / 3 = 0.0
IP: 101 -> Ejecutando: (=, 17001, None, 11026)
  Asignación: direccion[11026] = 0.0
IP: 102 -> Ejecutando: (RETURN, 11026, None, None)
  RETURN: Retornando valor 0
  ENDFUNC: Retornando a dirección 140
IP: 140 -> Ejecutando: (print, Promedio: , None, None)
OUTPUT: Promedio: 
IP: 141 -> Ejecutando: (print, 15017, None, None)
OUTPUT: 0
IP: 142 -> Ejecutando: (ENDFUNC, None, None, None)
  ENDFUNC: Retornando a dirección 207
IP: 207 -> Ejecutando: (print, , None, None)
OUTPUT: 
IP: 208 -> Ejecutando: (print, === FIN DEL PROGRAMA ===, None, None)
OUTPUT: === FIN DEL PROGRAMA ===
IP: 209 -> Ejecutando: (END, None, None, None)
  END: Terminando programa
=== EJECUCIÓN TERMINADA ===

=== ESTADO DE LA MEMORIA SEGMENTADA ===
Memoria Global Enteros (5000-7999):
  [5000]: 12
  [5001]: 8
  [5002]: 15
  [5003]: 0
  [5004]: 5
  [5005]: 0
Memoria Global Flotantes (8000-10999):
Memoria Local Enteros (11000-12999):
Memoria Local Flotantes (13000-14999):
Memoria Temporal Enteros (15000-16999):
  [15000]: 6
  [15001]: 120
  [15002]: 6
  [15003]: 4
  [15004]: 512
  [15005]: 4
  [15006]: 6
  [15007]: 40
  [15008]: 6
  [15009]: 20
  [15010]: 4
  [15011]: 96
  [15012]: 0
  [15013]: 0
  [15014]: 20
  [15015]: 35
Memoria Temporal Flotantes (17000-18999):
  [17000]: 1.5
  [17001]: 0.0
Memoria Temporal Booleanos (19000-19999):
  [19000]: False
  [19001]: False
  [19002]: False
  [19003]: False
  [19004]: False
  [19005]: True
  [19007]: True
  [19008]: True
  [19009]: True
  [19010]: False
Constantes Enteras (20000-20499):
  [20000]: 1
  [20001]: 0
  [20002]: 3
  [20003]: 12
  [20004]: 8
  [20005]: 15
  [20006]: 5
Constantes Flotantes (20500+):
========================================

RESULTADOS ESPERADOS:
  - === CALCULADORA AVANZADA ===
  - Números de trabajo:
  - 12
  - ,
  - 8
  - ,
  - 15
  - Operaciones básicas entre
  - 12
  - y
  - 8
  - Suma:
  - 20
  - Resta:
  - 4
  - Multiplicación:
  - 96
  - División:
  - 1
  - Analizando el número:
  - 12
  - El número es positivo
  - El número es par
  - Tabla de multiplicar del
  - 8
  - 8
  -  x 
  - 1
  -  = 
  - 8
  - 8
  -  x 
  - 5
  -  = 
  - 40
  - Factorial de
  - 5
  - es:
  - 120
  - 8
  - elevado a la 3 es:
  - 512
  - El mayor de los tres números es:
  - 15
  - El promedio de los tres números es:
  - 11
  - === ESTADÍSTICAS ===
  - Números:
  - 12
  - ,
  - 8
  - ,
  - 15
  - Suma total:
  - 35
  - Número mayor:
  - 15
  - Número menor:
  - 8
  - Promedio:
  - 11
  - === FIN DEL PROGRAMA ===

✅ PRUEBA EXITOSA
------------------------------------------------------------

================================================================================
RESUMEN DE PRUEBAS
================================================================================
Total de pruebas: 12
Pruebas exitosas: 12
Pruebas fallidas: 0
Porcentaje de éxito: 100.0%
================================================================================

